---
title: SQLSetStmtAttr-Funktion | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
caps.latest.revision: 32
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 7a1a861de024a59313bcf883b58d98b867261276
ms.sourcegitcommit: 2ddc0bfb3ce2f2b160e3638f1c2c237a898263f4
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 05/03/2018
---
# <a name="sqlsetstmtattr-function"></a>SQLSetStmtAttr-Funktion
**Konformität**  
 Version eingeführt: ODBC 3.0 Standardkonformität: ISO-92  
  
 **Zusammenfassung**  
 **SQLSetStmtAttr** Attribute, die im Zusammenhang mit einer Anweisung festgelegt.  
  
> [!NOTE]  
>  Weitere Informationen, was der Treiber-Manager diese Funktion auf, wenn eine ODBC 3. ordnet *.x* Anwendung arbeitet mit einer ODBC 2.*.x* -Treiber verwenden, finden Sie unter [Ersatzfunktionen für rückwärts zuordnen Die Kompatibilität der Anwendungen](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntax  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumente  
 *StatementHandle*  
 [Eingabe] Anweisungshandle.  
  
 *Attribut*  
 [Eingabe] Option, um festzulegen, abgelesen "Kommentare".  
  
 *ValuePtr*  
 [Eingabe] Wert zugeordnet werden *Attribut*. Abhängig vom Wert der *Attribut*, *ValuePtr* wird eines der folgenden sein:  
  
-   Eine ODBC-Deskriptorhandles.  
  
-   Eine SQLUINTEGER-Wert.  
  
-   Ein Wert SQLULEN erstellt wurde.  
  
-   Ein Zeiger auf eine der folgenden:  
  
    -   Eine Null-terminierte Zeichenfolge.  
  
    -   Ein binäres Puffer.  
  
    -   Ein Wert oder ein Array vom Typ SQLLEN, SQLULEN oder SQLUSMALLINT.  
  
    -   Ein Wert treiberdefinierten.  
  
 Wenn die *Attribut* Argument ist ein Wert treiberspezifische *ValuePtr* möglicherweise eine Ganzzahl mit Vorzeichen.  
  
 *stringLength*  
 [Eingabe] Wenn *Attribut* ist ein ODBC-definierten Attribut und *ValuePtr* zeigt auf eine Zeichenfolge oder einen binären Puffer, in dieses Argument muss die Länge des \* *ValuePtr*. Wenn *Attribut* ist ein ODBC-definierten Attribut und *ValuePtr* ist eine ganze Zahl *StringLength* wird ignoriert.  
  
 Wenn *Attribut* ist ein Attribut treiberdefinierten die Anwendung zeigt die Art des Attributs an den Treiber-Manager an, indem die *StringLength* Argument. *StringLength* können die folgenden Werte aufweisen:  
  
-   Wenn *ValuePtr* ist ein Zeiger auf eine Zeichenfolge *StringLength* ist die Länge der Zeichenfolge oder SQL_NTS.  
  
-   Wenn *ValuePtr* ist ein Zeiger auf einen binären Puffer, und klicken Sie dann die Anwendung das Ergebnis von der SQL_LEN_BINARY_ATTR eingefügt (*Länge*)-Makro im *StringLength*. Dies setzt einen negativen Wert in *StringLength*.  
  
-   Wenn *ValuePtr* ist ein Zeiger auf einen anderen Wert als eine Zeichenfolge oder eine binäre Zeichenfolge *StringLength* müssen den Wert SQL_IS_POINTER.  
  
-   Wenn *ValuePtr* enthält einen Wert fester Länge *StringLength* ist SQL_IS_INTEGER oder SQL_IS_UINTEGER, nach Bedarf.  
  
## <a name="returns"></a>Rückgabewert  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR oder SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnose  
 Wenn **SQLSetStmtAttr** gibt SQL_ERROR oder SQL_SUCCESS_WITH_INFO, einen zugeordneten SQLSTATE-Wert abgerufen werden können, durch den Aufruf **SQLGetDiagRec** mit einer *HandleType* von SQL Server _HANDLE_STMT und ein *behandeln* von *StatementHandle*. Die folgende Tabelle enthält die SQLSTATE-Werten, die häufig zurückgegebenes **SQLSetStmtAttr** und erläutert, jeweils im Kontext dieser Funktion; die Notation "(DM)" vorangestellt ist, die Beschreibungen der SQLSTATEs, die vom Treiber-Manager zurückgegeben. Der Rückgabecode, der jeden SQLSTATE-Wert zugeordnet wird SQL_ERROR zurückgegeben, sofern nicht anders angegeben.  
  
|SQLSTATE|Fehler|Description|  
|--------------|-----------|-----------------|  
|01000|Allgemeine Warnung|Treiberspezifische Meldung dient zu Informationszwecken. (Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|01S02|Der Optionswert wurde geändert|Der Treiber nicht den Wert im angegebenen *ValuePtr*, oder der Wert im angegebenen *ValuePtr* ungültig aufgrund Implementierung Arbeitsbedingungen, damit der Treiber einen ähnlichen Wert ersetzt. (**SQLGetStmtAttr** aufgerufen werden, um vorübergehend ersetzten Werts zu ermitteln.) Der Ersatzwert ist gültig für die *StatementHandle* , bis der Cursor geschlossen wird, an welchem Punkt das Anweisungsattribut zurückgesetzt auf seinen ursprünglichen Wert. Die Anweisungsattribute, die geändert werden können, sind:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|08S01|Kommunikations-Verbindungsfehler|Die Verbindung zwischen dem Treiber und die Datenquelle mit der der Treiber verbunden wurde aufgetreten ist, bevor die Verarbeitung für die Funktion abgeschlossen.|  
|24000|Ungültiger Cursorstatus|Die *Attribut* SQL_ATTR_CONCURRENCY SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR oder SQL_ATTR_USE_BOOKMARKS wurde und der Cursor geöffnet war.|  
|HY000|Allgemeiner Fehler|Für die es keine spezifischen SQLSTATE wurde und für die keine implementierungsabhängige SQLSTATE definiert wurde, ist ein Fehler aufgetreten. Die zurückgegebene Fehlermeldung **SQLGetDiagRec** in der  *\*MessageText* Puffer beschreibt den Fehler und seiner Ursache.|  
|HY001|Fehler bei der speicherbelegung|Der Treiber konnte nicht belegt werden zur Unterstützung der Ausführung oder den Abschluss der Funktion erforderlich.|  
|HY009|Ungültige Verwendung des null-Zeiger|Die *Attribut* Argument identifiziert ein Anweisungsattribut, die ein Zeichenfolgenattribut erforderlich und die *ValuePtr* Argument wurde ein null-Zeiger.|  
|HY010|Fehler bei Funktionssequenz|(DM) eine asynchron ausgeführte Funktion das, das zugeordnete Verbindungshandle hieß die *StatementHandle*. Diese asynchronen Funktion wurde weiterhin ausgeführt, wenn die **SQLSetStmtAttr** Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, oder **SQLMoreResults** wurde aufgerufen, die *StatementHandle* und SQL_PARAM_DATA_ zurückgegeben VERFÜGBAR. Diese Funktion wurde aufgerufen, bevor Daten für alle gestreamte Parameter abgerufen wurde.<br /><br /> (DM) eine asynchron ausgeführte Funktion wurde aufgerufen, für die *StatementHandle* und wurde noch ausgeführt werden, wenn diese Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, oder **SQLSetPos** wurde aufgerufen, für die  *StatementHandle* und SQL_NEED_DATA zurückgegeben. Diese Funktion wurde aufgerufen, bevor die Daten für alle Data-at-Execution-Parameter oder Spalten gesendet wurden.|  
|HY011|Attribut kann jetzt nicht festgelegt werden|Die *Attribut* SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR oder SQL_ ATTR_USE_BOOKMARKS wurde und die Anweisung vorbereitet wurde.|  
|HY013|Speicherverwaltungsfehler|Der Funktionsaufruf konnte nicht verarbeitet werden, da die zugrunde liegenden Speicherobjekte, möglicherweise aufgrund von unzureichendem Speicher konnte nicht zugegriffen werden.|  
|HY017|Ungültige Verwendung eines automatisch zugeordneten Deskriptorhandles|(DM) die *Attribut* Argument war SQL_ATTR_IMP_ROW_DESC oder SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) die *Attribut* Argument war SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC und der Wert im *ValuePtr* ursprünglich war ein implizit zugeordneten Deskriptorhandles als das Handle für die ARD oder APD zugeordnet.|  
|HY024|Ungültiger Attributwert|Berücksichtigung des angegebenen *Attribut* Wert, ein ungültiger Wert wurde angegeben, *ValuePtr*. (Der Treiber-Manager gibt SQLSTATE nur für Verbindungs- und Anweisungsattribute, die einen diskreten Satz von Werten, z. B. SQL_ATTR_ACCESS_MODE oder SQL_ ATTR_ASYNC_ENABLE akzeptieren. Für alle anderen Verbindungs- und Anweisungsattribute der Treiber muss überprüfen Sie den Wert im angegebenen *ValuePtr*.)<br /><br /> Die *Attribut* Argument war SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC, und *ValuePtr* wurde eine explizit zugeordneten Deskriptorhandles, die nicht über dieselbe Verbindung wie die  *StatementHandle* Argument.|  
|HY090|Ungültige Zeichenfolgen- oder Pufferlänge.|(DM)  *\*ValuePtr* ist eine Zeichenfolge, und die *StringLength* Argument war kleiner als 0 jedoch war nicht SQL_NTS.|  
|HY092|Ungültiger Attribut-/Optionsbezeichner|(DM) der Wert für das Argument angegebene *Attribut* war für die vom Treiber unterstützten ODBC-Version ungültig.<br /><br /> (DM) der Wert für das Argument angegebene *Attribut* wurde eine nur-Lese Attribut.|  
|HY117|Verbindung wird aufgrund eines unbekannten Transaktionsstatus angehalten. Nur trennen, und nur-Lese Funktionen sind zulässig.|(DM) finden Sie weitere Informationen zum Zustand "angehalten" [SQLEndTran-Funktion](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Optionales Feature nicht implementiert|Der Wert für das Argument angegebene *Attribut* wurde eine gültige ODBC-Anweisungsattribut für den ODBC-Version vom Treiber unterstützt, jedoch wurde vom Treiber nicht unterstützt.<br /><br /> Die *Attribut* Argument war SQL_ATTR_ASYNC_ENABLE und einem Aufruf von **SQLGetInfo** mit einer *Infotyp* SQL_ASYNC_MODE SQL_AM_CONNECTION zurückgibt.<br /><br /> Die *Attribut* Argument SQL_ATTR_ENABLE_AUTO_IPD und der Wert des Verbindungsattributs SQL_ATTR_AUTO_IPD wurde SQL_FALSE.|  
|HYT01|Verbindungstimeout abgelaufen|Das Verbindungstimeout ist abgelaufen, bevor die Datenquelle auf die Anforderung geantwortet hat. Das Verbindungstimeout wird über festgelegt **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Diese Funktion wird im Treiber nicht unterstützt.|(DM) der Treiber verknüpft sind, mit der *StatementHandle* der Funktion nicht unterstützt.|  
|S1118|Asynchrone Benachrichtigung unterstützt-Treiber nicht.|Wenn der Aufruf **SQLSetStmtAttr** festzulegende SQL_ATTR_ASYNC_STMT_EVENT; die asynchrone Benachrichtigung wird vom Treiber nicht unterstützt.|  
  
## <a name="comments"></a>Kommentare  
 Anweisungsattribute für eine Anweisung bleiben wirksam, bis sie von einem anderen Aufruf geändert werden **SQLSetStmtAttr** oder bis die Anweisung, durch den Aufruf gelöscht wird **SQLFreeHandle**. Aufrufen von **SQLFreeStmt** mit der SQL_CLOSE SQL_UNBIND bzw. SQL_RESET_PARAMS Option setzt nicht Anweisungsattribute.  
  
 Einige Anweisungsattribute unterstützen einen ähnlichen Wert ersetzen, wenn die Datenquelle im angegebene Wert nicht unterstützt *ValuePtr*. In solchen Fällen gibt der Treiber SQL_SUCCESS_WITH_INFO und SQLSTATE 01 s 02 (Optionswert wurde geändert). Z. B. wenn *Attribut* ist SQL_ATTR_CONCURRENCY und *ValuePtr* SQL_CONCUR_ROWVER ist, und wenn die Datenquelle nicht unterstützt wird, wird der Treiber ersetzt SQL_CONCUR_VALUES und SQL_ zurückgibt SUCCESS_WITH_INFO. Um ersetzten Werts zu ermitteln, eine Anwendung ruft **SQLGetStmtAttr**.  
  
 Legen Sie das Format der Daten mit *ValuePtr* richtet sich nach dem angegebenen *Attribut*. **SQLSetStmtAttr** akzeptiert Attributinformationen in einem, zwei unterschiedliche Formate an: eine Zeichenfolge oder einen ganzzahligen Wert. Das Format der einzelnen wird in das Attribut Beschreibung aufgeführt. Dieses Format gilt für jedes Attribut in die zurückgegebenen Informationen **SQLGetStmtAttr**. Zeichenfolgen, die durch die *ValuePtr* Argument **SQLSetStmtAttr** haben eine Länge von *StringLength*.  
  
> [!NOTE]  
>  Die Fähigkeit zum Festlegen von Anweisungsattribute auf der Verbindungsebene durch Aufrufen von **SQLSetConnectAttr** ist in ODBC 3. veraltet *.x*. ODBC 3.*.x* Anwendungen Anweisungsattribute auf Verbindungsebene darf nicht festgelegt werden. ODBC 3.*.x* Anweisungsattribute können nicht auf Verbindungsebene, mit Ausnahme der SQL_ATTR_METADATA_ID und SQL_ATTR_ASYNC_ENABLE-Attribute, die Verbindungsattribute und Anweisungsattribute sind, und kann nicht festgelegt werden Legen Sie auf der Verbindungsebene oder Anweisungsebene.  
  
> [!NOTE]  
>  ODBC 3.*.x* Treiber müssen nur diese Funktionalität unterstützen, wenn sie mit ODBC 2. arbeiten sollten *.x* Anwendung, die ODBC 2. festlegt *.x* Anweisungsoptionen auf Verbindungsebene. Weitere Informationen finden Sie unter "Einstellung Anweisung Optionen auf der Verbindungsebene" unter [SQLSetConnectOption Zuordnung](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) in Anhang G: Treiber Richtlinien für die Abwärtskompatibilität.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Anweisungsattribute, die Deskriptorfelder festlegen  
 Viele Anweisungsattribute entsprechen einem Headerfeld einen Deskriptor. Diese Attribute festlegen tatsächlich Ergebnisse in der Einstellung der Descriptor-Felder. Festlegen von Feldern durch einen Aufruf von **SQLSetStmtAttr** statt zu **SQLSetDescField** hat den Vorteil, die eine Deskriptorhandles nicht für den Funktionsaufruf abgerufen werden soll.  
  
> [!CAUTION]  
>  Aufrufen von **SQLSetStmtAttr** für eine Anweisung auf andere Anweisungen auswirken kann. Dies tritt auf, wenn APD oder der Anweisung zugeordneten ARD explizit zugeordnet ist, und auch andere Anweisungen zugeordnet ist. Da **SQLSetStmtAttr** ändert das APD oder ARD, die Änderungen zu übernehmen, um alle Anweisungen, denen dieses Deskriptors zugeordnet ist. Wenn dies nicht das erforderliche Verhalten ist, sollte die Anwendung dieses Deskriptors aus den anderen Anweisungen trennen (durch Aufrufen von **SQLSetStmtAttr** auf ein anderes Feld SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC fest Deskriptorhandles) vor dem Aufruf **SQLSetStmtAttr** erneut aus.  
  
 Wenn ein Deskriptorfeld als Ergebnis der entsprechende Anweisungsattribut festgelegt festgelegt ist, wird das Feld festgelegt, nur für die entsprechenden Deskriptoren, die mit der Anweisung identifizierte derzeit zugeordnet sind die *StatementHandle* Argument und der attributeinstellung wirkt sich keine Deskriptoren, die diese Anweisung in der Zukunft zugeordnet werden können. Wenn einem Beschreibungsfeld, das auch ein Anweisungsattribut festgelegt ist, durch einen Aufruf von **SQLSetDescField**, das entsprechende Anweisungsattribut festgelegt ist. Wenn von einer Anweisung ein explizit zugewiesenen Deskriptor getrennt ist, wird eine Anweisung-Attributs, das ein Headerfeld entspricht, der Wert des Felds im implizit zugeordneten Deskriptor wiederhergestellt.  
  
 Wenn eine Anweisung zugeordnet ist (finden Sie unter [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), vier Deskriptorhandles automatisch zugeordnet und der Anweisung zugeordnet werden. Explizit zugeordneten Deskriptorhandles können durch Aufrufen der Anweisung zugeordnet werden **SQLAllocHandle** mit einem *fHandleType* von SQL_HANDLE_DESC eine Deskriptorhandles aufrufen und anschließend zuweisen **SQLSetStmtAttr** die Anweisung die Deskriptorhandles zugeordnet werden soll.  
  
 In der folgenden Tabelle die Anweisungsattribute entsprechen deskriptorheaderfelder.  
  
|Anweisungsattribut|-Headerfeld|"DESC".|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR FEST|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Anweisungsattribute  
 Die aktuell definierten Attribute und die Version von ODBC, in denen sie eingeführt wurden, werden in der folgenden Tabelle angezeigt. Es wird erwartet, dass weitere Attribute von Treibern, die von verschiedenen Datenquellen nutzen definiert werden. ODBC ist ein Bereich von Attributen reserviert. Entwickler müssen Werte für die eigene Verwendung treiberspezifische von Open Group reservieren. Weitere Informationen finden Sie unter [Treiber-spezifische Datentypen, Deskriptor Typen Informationstypen, Diagnosetypen und Attribute](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribut|*ValuePtr* Inhalt|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Das Handle für die APD für nachfolgende Aufrufe **SQLExecute** und **SQLExecDirect** des Anweisungshandles. Der erste Wert dieses Attributs ist der Deskriptor implizit zugeordnet werden, wenn die Anweisung ursprünglich zugeordnet wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle, das ursprünglich zugeordnet wurde, für den Deskriptor festgelegt ist, einen explizit zugewiesenen APD-Handle, das zuvor das Anweisungshandle zugeordnet wurde von ihm getrennt ist und das Anweisungshandle zurückgesetzt wird, um die implizit reserviert APD Handle.<br /><br /> Dieses Attribut kann nicht festgelegt werden, um ein Deskriptor-Handle, das implizit für eine andere Anweisung zugewiesen wurde oder eine andere Deskriptorhandles, die implizit in derselben Anweisung festgelegt wurde; implizit zugeordneten Deskriptorhandles darf nicht mehr als eine Anweisung oder Deskriptorhandles zugeordnet sein.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Das Handle für die ARD für nachfolgende Abrufe des Anweisungshandles. Der erste Wert dieses Attributs ist der Deskriptor implizit zugeordnet werden, wenn die Anweisung ursprünglich zugeordnet wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle, das ursprünglich zugeordnet wurde, für den Deskriptor festgelegt ist, einen explizit zugewiesenen ARD-Handle, das zuvor das Anweisungshandle zugeordnet wurde von ihm getrennt ist und das Anweisungshandle zurückgesetzt wird, um die implizit reserviert ARD Handle.<br /><br /> Dieses Attribut kann nicht festgelegt werden, um ein Deskriptor-Handle, das implizit für eine andere Anweisung zugewiesen wurde oder eine andere Deskriptorhandles, die implizit in derselben Anweisung festgelegt wurde; implizit zugeordneten Deskriptorhandles darf nicht mehr als eine Anweisung oder Deskriptorhandles zugeordnet sein.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, ob eine Funktion mit dem Namen der angegebenen Anweisung asynchron ausgeführt wird:<br /><br /> SQL_ASYNC_ENABLE_OFF = Disable-Anweisung auf asynchrone Ausführung-Unterstützung (Standard).<br /><br /> SQL_ASYNC_ENABLE_ON = Aktivieren der Unterstützung für Ebene asynchrone Ausführung-Anweisung.<br /><br /> Weitere Informationen finden Sie unter [asynchrone Ausführung (Methode abrufen)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Für den Treiber mit Unterstützung für Ebene asynchrone Ausführung der Anweisung ist das Anweisungsattribut SQL_ATTR_ASYNC_ENABLE schreibgeschützt. Der Wert entspricht dem als Wert für das Ebenenattribut der Verbindung mit dem gleichen Namen zu dem Zeitpunkt, den das Anweisungshandle zugeordnet wurde.<br /><br /> Aufrufen von **SQLSetStmtAttr** festzulegende SQL_ATTR_ASYNC_ENABLE bei der SQL_ASYNC_MODE *Infotyp* SQL_AM_CONNECTION zurückgegeben SQLSTATE HYC00 (optionales Feature nicht implementiert). Weitere Informationen finden Sie unter [Funktion SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) für Weitere Informationen.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Ein SQLPOINTER-Wert, der ein Ereignishandle ist.<br /><br /> Benachrichtigung Abschluss des asynchronen Funktionen aktiviert ist, durch den Aufruf **SQLSetStmtAttr** festzulegende der **SQL_ATTR_ASYNC_STMT_EVENT** -Attributs angibt und das Ereignishandle.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Eine SQLPOINTER an die asynchrone Rückruffunktion.<br /><br /> Nur der Treiber-Manager eines Treibers aufrufen können **SQLSetStmtAttr** Funktion mit diesem Attribut.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Eine SQLPOINTER auf Context-Struktur<br /><br /> Nur der Treiber-Manager eines Treibers aufrufen können **SQLSetStmtAttr** Funktion mit diesem Attribut.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Ein SQLULEN-Wert, der Cursorparallelität angibt:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor ist schreibgeschützt. Es sind keine Updates zulässig.<br /><br /> SQL_CONCUR_LOCK = Cursor verwendet die niedrigste Ebene von Sperren ausreichend, um sicherzustellen, dass die Zeile aktualisiert werden kann.<br /><br /> SQL_CONCUR_ROWVER = Cursor verwendet Steuerung durch vollständige Parallelität, Vergleichen von Zeilenversionen, z. B. SQLBase ROWID oder Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor verwendet Steuerung durch vollständige Parallelität, Vergleichen von Werten.<br /><br /> Der Standardwert für SQL_ATTR_CONCURRENCY ist SQL_CONCUR_READ_ONLY.<br /><br /> Dieses Attribut kann nicht für einen geöffneten Cursor nicht angegeben werden. Weitere Informationen finden Sie unter [Parallelitätstypen](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Wenn die SQL_ATTR_CURSOR_TYPE *Attribut* geändert wird, ein Typ, der den aktuellen Wert der SQL_ATTR_CONCURRENCY nicht unterstützt, wird der Wert der SQL_ATTR_CONCURRENCY zur Ausführungszeit und eine Warnung ausgegeben, wenn geändertwerden**SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn der Treiber unterstützt die **SELECT FOR UPDATE** -Anweisung und eine solche Anweisung ausgeführt wird, während der Wert der SQL_ATTR_CONCURRENCY auf SQL_CONCUR_READ_ONLY festgelegt ist, wird ein Fehler zurückgegeben. Wenn der Wert der SQL_ATTR_CONCURRENCY auf einen Wert, die die Treiber für einen Wert von SQL_ATTR_CURSOR_TYPE, aber nicht für den aktuellen Wert der SQL_ATTR_CURSOR_TYPE unterstützt geändert wird, wird der Wert von SQL_ATTR_CURSOR_TYPE zur Ausführungszeit und SQLSTATE 01 s 02 geändert werden (Der Optionswert wurde geändert) wird ausgegeben, wenn **SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn die angegebene Parallelität nicht von der Datenquelle unterstützt wird, wird der Treiber ersetzt durch eine andere Parallelität und gibt SQLSTATE 01 s 02 (Optionswert wurde geändert). Für SQL_CONCUR_VALUES, ersetzt der Treiber SQL_CONCUR_ROWVER, und umgekehrt. Bei SQL_CONCUR_LOCK ersetzt der Treiber in der Reihenfolge, SQL_CONCUR_ROWVER oder SQL_CONCUR_VALUES. Die Gültigkeit des ersetzten Werts wird bis zur Ausführungszeit nicht überprüft.<br /><br /> Weitere Informationen über die Beziehung zwischen SQL_ATTR_CONCURRENCY und die andere Cursorattribute finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Ein SQLULEN-Wert, der das Maß an Unterstützung gibt an, die die Anwendung erforderlich sind. Dieses Attribut wirkt sich auf nachfolgende Aufrufe **SQLExecDirect** und **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Scrollable-Cursor sind nicht erforderlich, über das Anweisungshandle. Wenn die Anwendung aufruft, **SQLFetchScroll** auf dieses Handle, der einzige gültige Wert von *FetchOrientation* ist SQL_FETCH_NEXT. Dies ist die Standardeinstellung.<br /><br /> SQL_SCROLLABLE = Scrollable-Cursor sind erforderlich, über das Anweisungshandle. Beim Aufrufen von **SQLFetchScroll**, die Anwendung möglicherweise Geben Sie einen gültigen Wert der *FetchOrientation*, cursorpositionierung in anderen Modi als den sequenziellen Modus erreichen.<br /><br /> Weitere Informationen über bildlauffähigen Cursor finden Sie unter [bildlauffähige Cursor](../../../odbc/reference/develop-app/scrollable-cursors.md). Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_SCROLLABLE und die andere Cursorattribute finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, ob der Cursor über das Anweisungshandle sichtbar zu machen festlegen die zu einem Ergebnis vorgenommenen Änderungen von einem anderen Cursor. Dieses Attribut wirkt sich auf nachfolgende Aufrufe **SQLExecDirect** und **SQLExecute**. Eine Anwendung kann wieder Lesen der Wert dieses Attributs auf seinen anfänglichen aktiven Status oder seinen Status wie die meisten vor kurzem Abrufen von der Anwendung festgelegt.<br /><br /> SQL_UNSPECIFIED = es ist eine nicht angegeben, was die Cursor-Datentyp ist, und gibt an, ob der Cursor über das Anweisungshandle sichtbar in einem Ergebnissatz durch einen anderen Cursor vorgenommenen Änderungen zu machen. Der Cursor über das Anweisungshandle möglicherweise keine, einige oder alle solche Änderungen sichtbar. Dies ist die Standardeinstellung.<br /><br /> SQL_INSENSITIVE = alle Cursor auf Anweisung Handle zum Anzeigen des Resultsets ohne spiegeln alle Änderungen an ihn durch einen anderen Cursor ausgeführt wird. INSENSITIVE-Cursor sind schreibgeschützt. Dies entspricht einem statischen Cursor, der gleichzeitige, die verfügt schreibgeschützt ist.<br /><br /> SQL_SENSITIVE = alle Cursor auf die Anweisung Handle sichtbar alle Änderungen an der ein Ergebnis von einem anderen Cursor festlegen.<br /><br /> Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_SENSITIVITY und die andere Cursorattribute finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Ein SQLULEN-Wert, der den Cursortyp angibt:<br /><br /> SQL_CURSOR_FORWARD_ONLY = der Cursor nur einen Bildlauf vorwärts.<br /><br /> SQL_CURSOR_STATIC = die Daten in das Ergebnis ist statisch.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = der Treiber gespeichert und verwendet die Schlüssel für die Anzahl der Zeilen, die in das Anweisungsattribut SQL_ATTR_KEYSET_SIZE angegeben.<br /><br /> SQL_CURSOR_DYNAMIC = der Treiber gespeichert und nur die Schlüssel für die Zeilen im Rowset verwendet.<br /><br /> Der Standardwert ist SQL_CURSOR_FORWARD_ONLY. Dieses Attribut kann nicht angegeben werden, nachdem die SQL-Anweisung vorbereitet wurde.<br /><br /> Wenn der angegebene Cursortyp nicht von der Datenquelle unterstützt wird, wird der Treiber ersetzt den ein anderen Cursortyps und SQLSTATE 01 s 02 zurückgibt (Optionswert wurde geändert). Für den gemischten oder dynamischen Cursor ersetzt der Treiber in der Reihenfolge, einen Keysetgesteuerte oder statische Cursor. Bei einem keysetgesteuerten Cursor ersetzt der Treiber einen statischen Cursor.<br /><br /> Weitere Informationen zu Datentypen für einen bildlauffähigen Cursor finden Sie unter [bildlauffähigen Cursortypen](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_TYPE und die andere Cursorattribute finden Sie unter [Cursormerkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Ein SQLULEN-Wert, der angibt, ob die automatischer Auffüllung der die IPD ausgeführt wird:<br /><br /> SQL_TRUE = Schaltet auf automatische Auffüllung der die IPD nach einem Aufruf von **SQLPrepare**. SQL_FALSE = Schaltet die automatische Auffüllung von den IPD nach einem Aufruf von **SQLPrepare**. (Eine Anwendung weiterhin Informationen erhalten Sie IPD Feld durch den Aufruf **SQLDescribeParam**, sofern unterstützt.) Der Standardwert des Attributs Anweisung SQL_ATTR_ENABLE_AUTO_IPD wird SQL_FALSE. Weitere Informationen finden Sie unter [automatische Auffüllung der die IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Eine SQLLEN \* , der auf eine binäre lesezeichenwerts verweist. Wenn **SQLFetchScroll** aufgerufen wird und *fFetchOrientation* gleich sql_fetch_bookmark auf, der Treiber übernimmt aus dem Lesezeichenwert dieses Felds. Dieses Feld ist standardmäßig auf einen null-Zeiger. Weitere Informationen finden Sie unter [Durchführen eines Bildlaufs durch Lesezeichen](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Der Wert, der verweist dieses Felds ist nicht zum Löschen von Lesezeichen verwendet, aktualisieren, indem Sie Lesezeichen oder Abrufen von Lesezeichen-Vorgängen in **SQLBulkOperations**, verwenden Sie die Lesezeichen im Rowset Puffer zwischengespeichert.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Das Handle für das IPD. Der Wert dieses Attributs ist der Deskriptor zugeordnet, wenn die Anweisung ursprünglich zugeordnet wurde. Die Anwendung kann nicht auf dieses Attribut festgelegt.<br /><br /> Dieses Attribut abgerufen werden kann, durch den Aufruf von **SQLGetStmtAttr** jedoch nicht durch einen Aufruf von **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Das Handle IRD. Der Wert dieses Attributs ist der Deskriptor zugeordnet, wenn die Anweisung ursprünglich zugeordnet wurde. Die Anwendung kann nicht auf dieses Attribut festgelegt.<br /><br /> Dieses Attribut abgerufen werden kann, durch den Aufruf von **SQLGetStmtAttr** jedoch nicht durch einen Aufruf von **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Ein SQLULEN erstellt wurde, der die Anzahl der Zeilen in das Keyset eines keysetgesteuerten Cursors angibt. Wenn die Keysetgröße 0 (Standard) ist, ist der Cursor Keyset-gesteuerten. Wenn die Keysetgröße größer als 0 ist, wird der Cursor (innerhalb des Keysets keysetgesteuerte und dynamische außerhalb der Keyset) gemischt. Die Standardgröße der Keyset ist 0. Weitere Informationen zu keysetgesteuerten Cursorn finden Sie unter [keysetgesteuerte Cursor](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Wenn die angegebene Größe der maximalen Keysetgröße überschreitet, wird der Treiber ersetzt diese Größe und gibt SQLSTATE 01 s 02 (Optionswert wurde geändert).<br /><br /> **SQLFetch** oder **SQLFetchScroll** gibt einen Fehler zurück, wenn die Keysetgröße größer als 0 und kleiner als die Rowsetgröße ist.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, die maximale Datenmenge, die der Treiber aus einem Zeichen oder binary-Spalte zurückgibt. Wenn *ValuePtr* ist kleiner als die Länge der verfügbaren Daten **SQLFetch** oder **SQLGetData** schneidet die Daten ab und gibt SQL_SUCCESS zurück. Wenn *ValuePtr* ist 0 (Standard), wird der Treiber versucht, alle verfügbare Daten zurückgegeben.<br /><br /> Wenn die angegebene Länge ist kleiner als die minimale Datenmenge, die von die Datenquelle zurückgegeben werden kann oder größer als die maximale Menge an Daten, die von die Datenquelle zurückgegeben werden kann, die Treiber ersetzt, der Wert und gibt SQLSTATE 01 s 02 (Optionswert wurde geändert).<br /><br /> Bei einem geöffneten Cursor kann der Wert dieses Attributs festgelegt werden. allerdings die Einstellung möglicherweise nicht sofort wirksam, in diesem Fall der Treiber SQLSTATE 01 s 02 zurückgibt (Optionswert wurde geändert) und das Attribut auf den ursprünglichen Wert zurücksetzen.<br /><br /> Dieses Attribut ist vorgesehen, um den Netzwerkverkehr zu reduzieren und sollten werden nur unterstützt, wenn die Datenquelle (im Gegensatz zu den Treiber) ein Treiber mehreren Ebenen implementiert werden kann. Dieser Mechanismus sollte nicht von Anwendungen verwendet werden, um das Abschneiden von Daten; zum Abschneiden von Datenempfangs empfangen werden, sollte eine Anwendung angeben, die maximale Länge in der *Pufferlänge* Argument in **SQLBindCol** oder **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Ein SQLULEN Wert, der die maximale Anzahl der Zeilen zur Rückgabe an die Anwendung für eine **wählen** Anweisung. Wenn \* *ValuePtr* gleich 0 (Standard), die der Treiber gibt alle Zeilen zurück.<br /><br /> Dieses Attribut ist vorgesehen, um den Netzwerkverkehr zu reduzieren. Im Prinzip es angewendet wird, wenn das Resultset erstellt wird, und das Resultset auf den ersten beschränkt *ValuePtr* Zeilen. Wenn die Anzahl der Zeilen im Resultset übersteigt *ValuePtr*, das Resultset wird abgeschnitten.<br /><br /> SQL_ATTR_MAX_ROWS gilt für alle Resultsets auf die *Anweisung*, einschließlich von Katalogfunktionen zurückgegeben wird. SQL_ATTR_MAX_ROWS richtet ein Maximum für den Wert der Zeilenanzahl Cursor.<br /><br /> Ein Treiber emuliert sollten SQL_ATTR_MAX_ROWS Verhalten für nicht **SQLFetch** oder **SQLFetchScroll** (sofern in der Datenquelle Ergebnis Satz größenbeschränkungen implementiert werden können), wenn es keine Garantie, SQL_ATTR_ MAX_ROWS wird ordnungsgemäß implementiert werden.<br /><br /> Es ist treiberdefinierten, Anweisungen als SELECT-Anweisungen (z. B. Katalogfunktionen) gibt an, ob SQL_ATTR_MAX_ROWS gilt.<br /><br /> Bei einem geöffneten Cursor kann der Wert dieses Attributs festgelegt werden. allerdings die Einstellung möglicherweise nicht sofort wirksam, in diesem Fall der Treiber SQLSTATE 01 s 02 zurückgibt (Optionswert wurde geändert) und das Attribut auf den ursprünglichen Wert zurücksetzen.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Ein SQLULEN-Wert, der bestimmt, wie die Zeichenfolgenargumente von Katalogfunktionen behandelt werden.<br /><br /> Wenn SQL_TRUE, das Zeichenfolgenargument von Katalogfunktionen als Bezeichner behandelt werden. Die Groß-/Kleinschreibung ist nicht signifikant. Der Treiber entfernt nachgestellten Leerzeichen als begrenzungsbezeichnern Zeichenfolgen und die Zeichenfolge in Großbuchstaben gefaltet wird. Für durch Trennzeichen getrennten Zeichenfolgen wird der Treiber keine führenden oder nachfolgenden Leerzeichen entfernt und akzeptiert, was als solcher zwischen den Trennzeichen ist. Wenn eins dieser Argumente auf einen null-Zeiger festgelegt ist, gibt die Funktion SQL_ERROR und SQLSTATE HY009 (Ungültige Verwendung eines null-Zeiger).<br /><br /> Wenn SQL_FALSE, die Zeichenfolgenargumente von Katalogfunktionen nicht als Bezeichner behandelt werden. Die Groß-/Kleinschreibung spielt. Sie können entweder eine Zeichenfolge Suchmuster oder nicht, je nach dem Argument enthalten.<br /><br /> Der Standardwert ist SQL_FALSE.<br /><br /> Die *TableType* Argument **SQLTables**, der eine Liste mit Werten, akzeptiert wird durch dieses Attribut nicht beeinflusst.<br /><br /> SQL_ATTR_METADATA_ID kann auch auf der Verbindungsebene festgelegt werden. (Es und SQL_ATTR_ASYNC_ENABLE sind die einzige Anweisung-Attribute, die auch Verbindungsattribute sind.)<br /><br /> Weitere Informationen finden Sie unter [Argumente in Katalogfunktionen](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Ein SQLULEN-Wert, der angibt, ob der Treiber SQL-Verbindungszeichenfolgen für Escapesequenzen suchen soll:<br /><br /> SQL_NOSCAN_OFF = scannt die Treiber SQL-Verbindungszeichenfolgen für Escapesequenzen (Standard).<br /><br /> SQL_NOSCAN_ON = scannt der Treiber keine SQL-Verbindungszeichenfolgen für Escapesequenzen. Stattdessen sendet der Treiber die Anweisung direkt mit der Datenquelle.<br /><br /> Weitere Informationen finden Sie unter [Escapesequenzen in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Ein SQLULEN * Wert, der auf einen Zeiger auf die Bindung des dynamischen Parametern ändern hinzugefügt Offset verweist. Wenn dieses Feld nicht Null ist, der Treiber dereferenziert den Zeiger, fügt den verweislosen Wert jedem der zurückgestellten Felder im Deskriptordatensatz (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) und verwendet die neuen Zeigerwerte Beim Binden. Es ist festgelegt, standardmäßig auf null.<br /><br /> Die Bind-Offset wird immer direkt auf die SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR Felder hinzugefügt. Wenn der Offset in einen anderen Wert geändert wird, wird der neue Wert weiterhin direkt mit dem Wert im Feld "Beschreibung" hinzugefügt. Der neue Offset ist der Wert des Felds sowie alle früheren Offsets nicht hinzugefügt.<br /><br /> Weitere Informationen finden Sie unter [Parameter binden Offsets](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_BIND_OFFSET_PTR-Feld im APD-Header fest.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Ein SQLULEN-Wert, der die Ausrichtung der Bindung für dynamische Parameter verwendet werden soll angibt.<br /><br /> Dieses Feld ist auf SQL_PARAM_BIND_BY_COLUMN (Standard) festgelegt, um spaltenbezogene Bindungen auszuwählen.<br /><br /> Zum Auswählen der zeilenbezogenen Bindung wird dieses Feld festgelegt, auf die Länge der Struktur oder eine Instanz eines Puffers, der auf einen Satz von dynamischen Parametern gebunden wird. Diese Länge muss Platz für alle gebundenen Parameter und möglicherweise vorhandene Auffüllzeichen der Struktur bzw. des Puffers, um sicherzustellen, dass bei der die Adresse des gebundenen Parameter mit der angegebenen Länge erhöht wird, wird das Ergebnis auf den Anfang des denselben Parameter im nächsten zeigen enthalten Satz von Parametern. Bei Verwendung der *"sizeof"* -Operator in ANSI C, wird dieses Verhalten garantiert.<br /><br /> Weitere Informationen finden Sie unter [Arrays der Bindungsparameter](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ BIND_TYPE-Feld im APD-Header fest.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* Wert, der auf ein Array von Werten SQLUSMALLINT zeigt verwendet, um einen Parameter während der Ausführung einer SQL-Anweisung ignorieren. Jeder Wert wird auf SQL_PARAM_PROCEED (für den Parameter ausgeführt werden) oder SQL_PARAM_IGNORE (für die Parameter werden ignoriert) festgelegt.<br /><br /> Eine Reihe von Parametern kann während der Verarbeitung durch Festlegen den Statuswert in das Array verweist SQL_DESC_ARRAY_STATUS_PTR im APD zu SQL_PARAM_IGNORE ignoriert werden. Eine Reihe von Parametern wird verarbeitet, wenn der Statuswert auf SQL_PARAM_PROCEED festgelegt ist oder keine Elemente im Array festgelegt werden.<br /><br /> Dieses Anweisungsattribut kann ein null-Zeiger festgelegt werden, in dem Fall der Treiber keine Parameter Statuswerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLExecDirect** oder **SQLExecute** aufgerufen wird.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundene Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ARRAY_STATUS_PTR-Feld im APD-Header fest.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* -Wert, der auf ein Array von SQLUSMALLINT zeigt Werten enthält Statusinformationen für jede Zeile von Parameterwerten nach einem Aufruf von **SQLExecute** oder **SQLExecDirect**. Dieses Feld ist erforderlich, nur wenn PARAMSET_SIZE größer als 1 ist.<br /><br /> Die Statuswerte können die folgenden Werte enthalten:<br /><br /> SQL_PARAM_SUCCESS: Die SQL-Anweisung wurde erfolgreich für diesen Satz von Parametern ausgeführt.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: Die SQL-Anweisung wurde erfolgreich für diesen Satz von Parametern ausgeführt. Warnungsinformationen steht jedoch in der Diagnose-Datenstruktur.<br /><br /> SQL_PARAM_ERROR: Fehler bei der Verarbeitung dieser Satz von Parametern. Zusätzliche Fehlerinformationen ist in der Diagnose-Datenstruktur verfügbar.<br /><br /> SQL_PARAM_UNUSED: Dieses Parametersatzes wurde nicht verwendet, möglicherweise darauf zurückzuführen, dass einige vorherigen Parametersatz einen Fehler verursacht hat, der weitere Verarbeitung abgebrochen, oder weil für diesen Satz von Parametern in das Array, das gemäß der SQL_ATTR_PARAM_ SQL_PARAM_IGNORE festgelegt wurde OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: Der Treiber Arrays von Parametern als monolithischen Einheit behandelt und generiert daher keine dieses Maß an Fehlerinformationen.<br /><br /> Dieses Anweisungsattribut kann ein null-Zeiger festgelegt werden, in dem Fall der Treiber keine Parameter Statuswerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLExecute** oder **SQLExecDirect** aufgerufen wird. Beachten Sie, dass dieses Attribut das Ausgabeverhalten-Parameter vom Treiber implementierte auswirken kann.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ARRAY_STATUS_PTR-Feld in den IPD-Header fest.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Ein SQLULEN \* Datensatzfeldaustausch, die auf einen Puffer, in dem die Anzahl von Parametersätzen zurückgegeben, die verarbeitet worden sind, einschließlich Fehler, verweist. Wenn dies ein null-Zeiger ist, wird keine Anzahl zurückgegeben.<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ROWS_PROCESSED_PTR-Feld in den IPD-Header fest.<br /><br /> Wenn der Aufruf von **SQLExecDirect** oder **SQLExecute** füllt die Puffer, die auf den von diesem Attribut keinen SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurückgibt, den Inhalt des Puffers nicht definiert sind.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Ein SQLULEN-Wert, der die Anzahl der Werte für jeden Parameter angibt. Wenn SQL_ATTR_PARAMSET_SIZE größer als 1 ist, zeigen Sie SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR von APD auf Arrays an. Die Kardinalität jedes Arrays ist gleich dem Wert dieses Felds.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundene Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Arrays von Parametern mithilfe von](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Festlegen dieses Attributs Anweisung legt das Feld SQL_DESC_ARRAY_SIZE im APD-Header fest.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Ein SQLULEN-Wert entspricht der Anzahl der Sekunden für eine SQL-Anweisung vor der Rückgabe an die Anwendung ausgeführt. Wenn *ValuePtr* ist gleich 0 (Standard), ist kein Timeout festgelegt.<br /><br /> Wenn das festgelegte Timeout das maximale Timeout in der Datenquelle überschreitet oder kleiner als der minimale Timeout ist **SQLSetStmtAttr** ersetzt durch diesen Wert und gibt SQLSTATE 01 s 02 (Optionswert wurde geändert).<br /><br /> Beachten Sie, die die Anwendung nicht aufrufen muss **SQLCloseCursor** , die Anweisung erneut zu verwenden, wenn eine **wählen** Anweisung Timeout.<br /><br /> Das Zeitlimit für Abfragen in dieser Anweisungsattribut festgelegt ist in synchronen und asynchronen Modus gültig.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Ein Wert SQLULEN erstellt wurde:<br /><br /> SQL_RD_ON = **SQLFetchScroll** und in ODBC 3.*.x*, **SQLFetch** Abrufen von Daten nach der die Position des Cursors an den angegebenen Speicherort. Dies ist die Standardeinstellung.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** und in ODBC 3.*.x*, **SQLFetch** Daten nicht abrufen, nachdem die Position des Cursors.<br /><br /> SQL_RETRIEVE_DATA auf SQL_RD_OFF festlegen, kann eine Anwendung überprüfen, ob eine Zeile vorhanden ist oder ein Lesezeichen für die Zeile abzurufen, ohne den Mehraufwand zum Abrufen von Zeilen. Weitere Informationen finden Sie unter [Bildlauf und Abrufen von Zeilen](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Bei einem geöffneten Cursor kann der Wert dieses Attributs festgelegt werden. allerdings die Einstellung möglicherweise nicht sofort wirksam, in diesem Fall der Treiber SQLSTATE 01 s 02 zurückgibt (Optionswert wurde geändert) und das Attribut auf den ursprünglichen Wert zurücksetzen.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Ein SQLULEN-Wert, der die Anzahl der Zeilen, die bei jedem Aufruf zurückgegebene angibt **SQLFetch** oder **SQLFetchScroll**. Es ist auch die Anzahl der Zeilen in einem Lesezeichen-Array verwendet, die in einem Lesezeichen Massenvorgang in **SQLBulkOperations**. Der Standardwert ist 1.<br /><br /> Überschreitet die Größe des angegebenen Rowsets die maximale Rowsetgröße, die von der Datenquelle unterstützt, wird der Treiber ersetzt diesen Wert und gibt SQLSTATE 01 s 02 (Optionswert wurde geändert).<br /><br /> Weitere Informationen finden Sie unter [Rowsetgröße](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ARRAY_SIZE-Feld in der Kopfzeile ARD fest.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Ein SQLULEN * Wert, der auf einen Zeiger auf die Bindung der Spaltendaten ändern hinzugefügt Offset verweist. Wenn dieses Feld nicht Null ist, der Treiber dereferenziert den Zeiger, fügt den verweislosen Wert jedem der zurückgestellten Felder im Deskriptordatensatz (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) und verwendet die neuen Zeigerwerte Beim Binden. Es ist festgelegt, standardmäßig auf null.<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_BIND_OFFSET_PTR-Feld in der Kopfzeile ARD fest.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Ein SQLULEN-Wert, der legt die Ausrichtung der Bindung zu verwendende **SQLFetch** oder **SQLFetchScroll** für die zugehörige Anweisung aufgerufen wird. Die spaltenweise Bindung wird durch Festlegen des Werts auf SQL_BIND_BY_COLUMN ein ausgewählt. Zeilenweise Bindung wird durch Festlegen des Werts auf die Länge einer Struktur oder eine Instanz eines Puffers in die Ergebnisspalten gebunden werden ausgewählt.<br /><br /> Wenn eine Länge angegeben wird, muss sie enthalten Speicherplatz für alle gebundenen Spalten und möglicherweise vorhandene Auffüllzeichen der Struktur bzw. des Puffers, um sicherzustellen, dass bei der die Adresse einer gebundenen Spalte mit der angegebenen Länge erhöht wird, wird das Ergebnis an den Anfang derselben Spalte th zeigen e nächste Zeile. Bei Verwendung der **"sizeof"** -Operator mit Struktur- oder Union in ANSI C, wird dieses Verhalten garantiert.<br /><br /> Die standardausrichtung für die Bindung für die spaltenweise Bindung ist **SQLFetch** und **SQLFetchScroll**.<br /><br /> Weitere Informationen finden Sie unter [Binden von Spalten für die Verwendung mit Blockcursor](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_BIND_TYPE-Feld in der Kopfzeile ARD fest.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Ein SQLULEN-Wert, der die Anzahl der aktuellen Zeile in das gesamte Resultset wird festgelegt. Wenn die Anzahl der aktuellen Zeile kann nicht bestimmt werden, oder keine aktuelle Zeile vorhanden ist, gibt der Treiber 0 zurück.<br /><br /> Dieses Attribut abgerufen werden kann, durch den Aufruf von **SQLGetStmtAttr** jedoch nicht durch einen Aufruf von **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* Wert, der auf ein Array von Werten SQLUSMALLINT zeigt verwendet wird, um eine Zeile bei einem Vorgang mithilfe ignorieren **SQLSetPos**. Jeder Wert wird auf SQL_ROW_PROCEED (für die Zeile in der Massenvorgang aufgenommen werden) oder SQL_ROW_IGNORE (für die Zeile aus der Massenvorgang ausgeschlossen werden sollen) festgelegt. (Zeilen nicht ignoriert werden, mithilfe dieses Array während des Aufrufs **SQLBulkOperations**.)<br /><br /> Dieses Anweisungsattribut kann ein null-Zeiger festgelegt werden, in dem Fall den Treiber nicht Status Zeilenwerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLSetPos** aufgerufen wird.<br /><br /> Weitere Informationen finden Sie unter [Aktualisieren von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) und [Löschen von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ARRAY_STATUS_PTR-Feld in der ARD fest.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Ein SQLUSMALLINT \* -Wert, der auf ein Array von SQLUSMALLINT zeigt Werten enthaltenden Zeile Statuswerte nach einem Aufruf von **SQLFetch** oder **SQLFetchScroll**. Das Array hat so viele Elemente als Zeilen im Rowset vorhanden sind.<br /><br /> Dieses Anweisungsattribut kann ein null-Zeiger festgelegt werden, in dem Fall den Treiber nicht Status Zeilenwerte zurückgibt. Dieses Attribut kann zu einem beliebigen Zeitpunkt festgelegt werden, aber der neue Wert wird nicht verwendet, bis das nächste Mal **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, oder  **SQLSetPos** aufgerufen wird.<br /><br /> Weitere Informationen finden Sie unter [Anzahl von Zeilen abgerufen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ARRAY_STATUS_PTR-Feld in den IRD-Header fest.<br /><br /> Dieses Attribut wird von einer ODBC 2. zugeordnet *.x* -Treiber die *RgbRowStatus* Array in einem Aufruf von **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Ein SQLULEN \* -Wert, der auf einen Puffer, in dem die Anzahl der nach einem Aufruf von abgerufenen Zeilen zurückgegeben **SQLFetch** oder **SQLFetchScroll**; die Anzahl der Zeilen, die von einem Massenvorgang betroffenen durchgeführten durch einen Aufruf von **SQLSetPos** mit einem *Vorgang* Argument SQL_REFRESH; oder die Anzahl der Zeilen, die einen Massenvorgang durchgeführte betroffen **SQLBulkOperations**. Diese Zahl umfasst Fehlerzeilen.<br /><br /> Weitere Informationen finden Sie unter [Anzahl von Zeilen abgerufen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Attributs Anweisung legt das SQL_DESC_ROWS_PROCESSED_PTR-Feld in den IRD-Header fest.<br /><br /> Wenn der Aufruf von **SQLFetch** oder **SQLFetchScroll** füllt die Puffer, die auf den von diesem Attribut keinen SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurückgibt, den Inhalt des Puffers nicht definiert sind.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, ob die Treiber, die simulieren positionierten Updates und delete-Anweisungen zu gewährleisten, dass solche Anweisungen nur eine einzelne Zeile auswirken.<br /><br /> Um simulieren positioniertes Update und delete-Anweisungen, die meisten Treiber erstellen Sie eine gesuchte **aktualisieren** oder **löschen** -Anweisung mit einer **, in dem** -Klausel, die angibt der der Wert der einzelnen Spalten in der aktuellen Zeile. Wenn diese Spalten einen eindeutigen Schlüssel bilden, kann eine solche Anweisung mehrere Zeilen auswirken.<br /><br /> Um zu gewährleisten, dass solche Anweisungen nur eine Zeile auswirken, wird der Treiber bestimmt die Spalten in einen eindeutigen Schlüssel und das Resultset auf diese Spalten hinzugefügt. Wenn eine Anwendung wird sichergestellt, dass die Spalten im Resultset einen eindeutigen Schlüssel bilden, muss der Treiber nicht dazu. Dies kann die Ausführungszeit beeinträchtigen.<br /><br /> SQL_SC_NON_UNIQUE = den Treiber ist nicht gewährleistet, die simulierte positioniert Update oder Delete-Anweisungen wirkt sich nur eine Zeile; Es ist die Anwendung die Verantwortung dafür. Wenn eine Anweisung mehrere Zeilen betrifft **SQLExecute**, **SQLExecDirect**, oder **SQLSetPos** SQLSTATE 01001 (Cursor Vorgang Konflikt) zurückgegeben.<br /><br /> SQL_SC_TRY_UNIQUE der Treiber versucht, zu gewährleisten, das sich simulierte Update = ' oder ' Anweisungen wirkt sich nur eine Zeile zu löschen. Der Treiber führt immer solchen Aussagen ist, auch wenn sie mehr als eine Zeile, z. B. wenn beeinflussen können keine eindeutiger Schlüssel vorhanden ist. Wenn eine Anweisung mehrere Zeilen betrifft **SQLExecute**, **SQLExecDirect**, oder **SQLSetPos** SQLSTATE 01001 (Cursor Vorgang Konflikt) zurückgegeben.<br /><br /> SQL_SC_UNIQUE = die Treiber Garantien, die simulierte positioniertes Update oder Anweisungen wirkt sich nur eine Zeile zu löschen. Wenn der Treiber dies für eine gegebene Anweisung nicht garantieren kann **SQLExecDirect** oder **SQLPrepare** gibt einen Fehler zurück.<br /><br /> Wenn die Datenquelle bietet systemeigene SQL-Unterstützung für positionierte Update und delete-Anweisungen und der Treiber ist nicht simulieren von Cursorn, wird SQL_SUCCESS zurückgegeben, wenn SQL_SC_UNIQUE für SQL_SIMULATE_CURSOR angefordert wird. Wenn SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE angefordert wird, wird SQL_SUCCESS_WITH_INFO zurückgegeben. Wenn der SQL_SC_TRY_UNIQUE Maß an Unterstützung der Datenquelle bereitgestellt, und der Treiber nicht der Fall, wird SQL_SUCCESS zurückgegeben, für für SQL_SC_NON_UNIQUE SQL_SC_TRY_UNIQUE und es wird SQL_SUCCESS_WITH_INFO zurückgegeben.<br /><br /> Wenn der Typ des angegebenen Cursors Simulation von der Datenquelle nicht unterstützt wird, wird der Treiber ersetzt durch einen anderen Simulation-Typ und gibt SQLSTATE 01 s 02 (Optionswert wurde geändert). Für SQL_SC_UNIQUE ersetzt der Treiber in der Reihenfolge, SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE. Für SQL_SC_TRY_UNIQUE ersetzt der Treiber SQL_SC_NON_UNIQUE.<br /><br /> Der Standardwert ist SQL_SC_UNIQUE.<br /><br /> Weitere Informationen finden Sie unter [simulieren positioniert Update und Delete-Anweisungen](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Ein SQLULEN-Wert, der angibt, ob eine Anwendung Lesezeichen mit einem Cursor verwendet:<br /><br /> SQL_UB_OFF = Off (Standardeinstellung)<br /><br /> SQL_UB_VARIABLE = eine Anwendung Lesezeichen mit einem Cursor verwendet werden soll, und der Treiber bereitgestellt variabler Länge Lesezeichen aus, wenn sie unterstützt werden. SQL_UB_FIXED veraltetes Feature in ODBC 3.*.x*. ODBC 3.*.x* Anwendungen sollten immer variabler Länge Lesezeichen verwenden, auch bei der Arbeit mit ODBC 2.*.x* Treiber (was nur 4-Byte, fester Länge Lesezeichen unterstützt). Dies ist ein fester Länge Lesezeichen ist nur ein Sonderfall eines Lesezeichens variabler Länge. Bei der Arbeit mit einer ODBC 2.*.x* Treiber, der Treiber-Manager ordnet SQL_UB_VARIABLE SQL_UB_FIXED.<br /><br /> Um Lesezeichen mit einem Cursor zu verwenden, muss die Anwendung dieses Attribut mit dem Wert SQL_UB_VARIABLE angeben, vor dem Öffnen des Cursors.<br /><br /> Weitere Informationen finden Sie unter [Lesezeichen abrufen](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] für diese Funktionen können asynchron aufgerufen werden, nur, wenn der Deskriptor eine Implementierung Deskriptor, keine Anwendungsdiensts ist.  
  
 Finden Sie unter [spaltenbezogene Bindungen](../../../odbc/reference/develop-app/column-wise-binding.md) und [zeilenbezogene Bindungen](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Verwandte Funktionen  
  
|Informationen zu|Finden Sie unter|  
|---------------------------|---------|  
|Anweisungsverarbeitung Abbrechen|[SQLCancel-Funktion](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Die Einstellung der Verbindungsattribut zurückgeben|[SQLGetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Die Einstellung eines Attributs Anweisung zurückgeben|[SQLGetStmtAttr-Funktion](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Ein Verbindungsattribut festlegen|[SQLSetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Ein einzelnes Feld des Deskriptors festlegen|[SQLSetDescField-Funktion](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Siehe auch  
 [ODBC-API-Referenz](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [ODBC-Headerdateien](../../../odbc/reference/install/odbc-header-files.md)
