---
title: Referenz zu logischen und physischen Showplanoperatoren | Microsoft-Dokumentation
ms.custom: 
ms.date: 03/14/2017
ms.prod: sql-server-2016
ms.reviewer: 
ms.suite: 
ms.technology:
- database-engine
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
caps.latest.revision: 51
author: BYHAM
ms.author: rickbyh
manager: jhubbard
translationtype: Human Translation
ms.sourcegitcommit: f3481fcc2bb74eaf93182e6cc58f5a06666e10f4
ms.openlocfilehash: f5b8af0e5293ff06927c043b2fb3aded1fab7591
ms.lasthandoff: 04/11/2017

---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referenz zu logischen und physischen Showplanoperatoren
  Operatoren beschreiben, wie eine Abfrage oder eine DML-Anweisung (Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ausgeführt wird. Der Abfrageoptimierer verwendet Operatoren, um einen Abfrageplan für das in der Abfrage angegebene Ergebnis zu erstellen, oder zum Ausführen des in der DML-Anweisung angegebenen Vorgangs. Der Abfrageplan ist eine Struktur, die aus physischen Operatoren besteht. Sie können den Abfrageplan mit den SET SHOWPLAN-Anweisungen, den grafischen Ausführungsplanoptionen in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], oder den SQL Server Profiler Showplan-Ereignisklassen anzeigen.  
  
 Operatoren werden als logische und physische Operatoren klassifiziert.  
  
 **Logische Operatoren**  
 Logische Operatoren beschreiben den relationalen algebraischen Vorgang, der für die Anweisungsverarbeitung verwendet wird. Mit anderen Worten, logische Operatoren beschreiben konzeptionell den auszuführenden Vorgang.  
  
 **Physische Operatoren**  
 Physische Operatoren implementieren den durch logische Operatoren beschriebenen Vorgang. Jeder physische Operator ist ein Objekt oder eine Routine, das bzw. die einen Vorgang ausführt. Einige Operatoren greifen z. B. auf Spalten oder Zeilen einer Tabelle, eines Index oder einer Sicht zu. Andere physische Operatoren führen andere Vorgänge aus, z. B. Berechnungen, Aggregationen, Datenintegritätsprüfungen oder Joins. Physischen Operatoren sind Kosten zugeordnet.  
  
 Über die physischen Operatoren werden Daten initialisiert, aufgelistet und beendet. Der physische Operator kann insbesondere die folgenden drei Methodenaufrufe beantworten:  
  
-   **Init()**: Mit der **Init()-Methode** wird ein physischer Operator initialisiert und dazu angewiesen, gegebenenfalls Datenstrukturen einzurichten. Der physische Operator kann mehrere **Init()** -Aufrufe empfangen; in der Regel empfängt er jedoch nur einen.  
  
-   **GetNext()**: Mit der **GetNext()** -Methode wird ein Operator angewiesen, die erste oder nächste Datenzeile abzurufen. Der physische Operator kann null oder mehrere **GetNext()** -Aufrufe empfangen.  
  
-   **Close()**: Mit der **Close()** -Methode wird der physische Operator dazu angewiesen, einige Cleanupvorgänge auszuführen und sich selbst zu beenden. Ein physischer Operator empfängt nur einen **Close()** -Aufruf.  
  
 Die **GetNext()**-Methode gibt eine Datenzeile zurück, und die Anzahl der Aufrufe wird als **ActualRows** in der durch SET STATISTICS PROFILE ON oder SET STATISTICS XML ON erstellten Showplanausgabe angezeigt. Weitere Informationen zu diesen SET-Optionen finden Sie unter [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-profile-transact-sql.md) und [SET STATISTICS XML &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
 Die **ActualRebinds**- und **ActualRewinds**-Zähler, die in der Showplanausgabe angezeigt werden, beziehen sich auf die Anzahl der Aufrufe der **Init()**-Methode. **ActualRebinds** entspricht 1 und **ActualRewinds** entspricht 0, es sei denn, ein Operator befindet sich innerhalb eines Schleifenjoins. Wenn sich ein Operator innerhalb eines Schleifenjoins befindet, muss die Summe der erneuten Bindungen und Zurückspulvorgänge der Anzahl der verarbeiteten Vorgänge außerhalb des Joins entsprechen. Unter 'erneuter Bindung' wird verstanden, dass sich mindestens ein korrelierter Parameter des Joins geändert hat und daher das Innere des Joins neu ausgewertet werden muss. Unter 'Zurückspulvorgang' wird verstanden, dass sich keiner der korrelierten Parameter geändert hat und das vorherige innere Resultset daher wiederverwendet werden kann.  
  
 **ActualRebinds** und **ActualRewinds** sind in der mithilfe von SET STATISTICS XML ON erstellten XML-Showplanausgabe vorhanden. Sie werden nur für die Operatoren **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**und **Table-valued Function** aufgefüllt. **ActualRebinds** und **ActualRewinds** können auch für den **Assert** - und den **Filter** -Operator aufgefüllt werden, wenn das **StartupExpression** -Attribut auf TRUE festgelegt ist.  
  
 Wenn **ActualRebinds** und **ActualRewinds** in einem XML-Showplan vorhanden sind, können sie mit **EstimateRebinds** und **EstimateRewinds**verglichen werden. Wenn sie nicht vorhanden sind, kann die geschätzte Zeilenanzahl (**EstimateRows**) mit der tatsächlichen Zeilenanzahl (**ActualRows**) verglichen werden. Beachten Sie, dass die tatsächliche grafische Showplanausgabe für tatsächliche erneute Bindungen und Zurückspulvorgänge Nullen anzeigt, wenn letztere nicht vorhanden sind.  
  
 Ein entsprechender Zähler, **ActualEndOfScans**, ist verfügbar, wenn die Showplanausgabe mithilfe von SET STATISTICS XML ON erstellt wird. Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht. Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht. Wie bei erneuten Bindungen und Zurückspulvorgängen kann die Anzahl für das Scanende größer als 1 sein; aber nur, wenn sich der Operator innerhalb eines Schleifenjoins befindet. Die Anzahl für Scanende muss kleiner oder gleich der Summe der erneuten Bindungen und Zurückspulvorgänge sein.  
  
## <a name="mapping-physical-and-logical-operators"></a>Zuordnen von physischen und logischen Operatoren  
 Der Abfrageoptimierer erstellt einen Abfrageplan als Struktur, die aus logischen Operatoren besteht. Nach dem Erstellen des Abfrageplans wählt der Abfrageoptimierer für jeden logischen Operator den effizientesten physischen Operator aus. Der Abfrageoptimierer entscheidet auf Basis der Kosten, welcher physischer Operator einen logischen Operator implementieren soll.  
  
 Normalerweise kann ein logischer Vorgang von mehreren physischen Operatoren implementiert werden. Ein physischer Operator kann jedoch in seltenen Fällen mehrere logische Vorgänge implementieren.  
  
## <a name="operator-descriptions"></a>Beschreibung der Operatoren  
 In diesem Abschnitt finden Sie Beschreibungen der logischen und physischen Operatoren.  
  
|Symbol für grafischen Ausführungsplan|Showplanoperator|Beschreibung|  
|-----------------------------------|-----------------------|-----------------|  
|Keine|**Aggregat**|Mit dem **Aggregate** -Operator wird ein Ausdruck berechnet, der MIN, MAX, SUM, COUNT oder AVG enthält. Der **Aggregate** -Operator kann ein logischer oder physischer Operator sein.|  
|![Operatorsymbol für arithmetische Ausdrücke (Symbol)](../relational-databases/media/arithmetic-expression-32x-2.gif "Operatorsymbol für arithmetische Ausdrücke (Symbol)")|**Arithmetic Expression**|Der **Arithmetic Expression** -Operator berechnet einen neuen Wert anhand vorhandener Werte in einer Zeile. **Arithmetic Expression** wird nicht in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]verwendet.|  
|![Assert-Operator (Symbol)](../relational-databases/media/assert-32x.gif "Assert-Operator (Symbol)")|**Assert**|Der **Assert** -Operator überprüft eine Bedingung. Beispielsweise überprüft er die referenzielle Integrität, oder er stellt sicher, dass eine skalare Unterabfrage eine Zeile zurückgibt. Für jede Eingabezeile wertet der **Assert** -Operator den Ausdruck in der **Argument** -Spalte des Ausführungsplans aus. Wird der Ausdruck mit NULL ausgewertet, so wird die Zeile an den **Assert** -Operator übergeben, und die Ausführung der Abfrage wird fortgesetzt. Wird dieser Ausdruck zu einem Nicht-NULL-Wert ausgewertet, so wird der entsprechende Fehler ausgelöst. Der **Assert** -Operator ist ein physischer Operator.|  
|![Assign-Sprachelement (Symbol)](../relational-databases/media/assign-32.gif "Assign-Sprachelement (Symbol)")|**Assign**|Der **Assign** -Operator weist einer Variablen den Wert eines Ausdrucks oder einer Konstanten zu. **Assign** ist ein Sprachelement.|  
|Keine|**Asnyc Concat**|Der **Asnyc Concat** -Operator wird nur in Remoteabfragen (verteilten Abfragen) verwendet. Diese Anweisung weist *n* untergeordnete Knoten und einen übergeordneten Knoten auf. Gewöhnlich sind manche untergeordnete Knoten Remotecomputer, die an einer verteilten Abfrage beteiligt sind. **Asnyc Concat** gibt `open()` -Aufrufe für alle untergeordneten Knoten gleichzeitig aus und weist dann auf jeden untergeordneten Knoten ein Bitmap an. Für jedes Bit, das 1 ist, sendet **Async Concat** bei Bedarf die Ausgabezeilen an den übergeordneten Knoten.|  
|![Bitmap-Operator (Symbol)](../relational-databases/media/bitmap-32x.gif "Bitmap-Operator (Symbol)")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] verwendet den **Bitmap** -Operator, um das Filtern mithilfe einer Bitmap in parallelen Abfrageplänen zu implementieren. Durch das Filtern mithilfe einer Bitmap kann die Abfrageausführung beschleunigt werden, indem Zeilen mit Schlüsselwerten eliminiert werden, die keine Joindatensätze erstellen können, bevor Zeilen durch einen anderen Operator wie den **Parallelism** -Operator übergeben werden. Ein Bitmapfilter verwendet eine kompakte Darstellung einer Gruppe von Werten aus einer Tabelle in einem Bereich der Operatorstruktur, um Zeilen aus einer zweiten Tabelle in einem anderen Bereich der Struktur zu filtern. Durch das Entfernen unnötiger Zeilen zu einem frühen Zeitpunkt in der Abfrage müssen nachfolgende Operatoren weniger Zeilen verarbeiten, wodurch eine Steigerung der Gesamtleistung der Abfrage erzielt werden kann. Der Optimierer bestimmt, wann eine Bitmap eine ausreichende Selektivität aufweist, damit sie verwendet werden kann, und in welchen Operatoren der Filter angewendet wird. Der**Bitmap** -Operator ist ein physischer Operator.|  
|![Bitmap-Operator (Symbol)](../relational-databases/media/bitmap-32x.gif "Bitmap-Operator (Symbol)")|**Bitmap Create**|Der **Bitmap Create** -Operator wird in der Showplanausgabe dort angezeigt, wo Bitmaps erstellt werden. **Bitmap Create** ist ein logischer Operator.|  
|![Bookmark Lookup-Operator (Symbol)](../relational-databases/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")|**Bookmark Lookup**|Der Operator **Bookmark Lookup** verwendet ein Lesezeichen (Zeilen-ID oder Gruppierungsschlüssel), um die zugehörige Zeile in der Tabelle oder im gruppierten Index nachzuschlagen. Die **Argument** -Spalte enthält das Lesezeichen, über das die Zeile in der Tabelle oder im gruppierten Index gesucht wird. Die **Argument** -Spalte enthält auch den Namen der Tabelle oder des gruppierten Indexes, wo die Zeile gesucht wird. Wenn die WITH PREFETCH-Klausel in der **Argument** -Spalte auftritt, hat der Abfrageprozessor ermittelt, dass Lesezeichen in der Tabelle oder im gruppierten Index am besten mit asynchronem Vorauslesen (Read-Ahead) nachgeschlagen werden sollten.<br /><br /> **Bookmark Lookup** wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]nicht verwendet. Die entsprechende Funktionalität wird hier von **Clustered Index Seek** und **RID Lookup** bereitgestellt. Auch der **Key Lookup** -Operator stellt diese Funktionalität bereit.|  
|Keine|**Branch Repartition**|Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten. Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden. Die Bereiche selbst müssen seriell ausgeführt werden. Bestimmte **Parallelism** -Iteratoren innerhalb eines einzelnen Bereichs werden **Branch Repartition**genannt. Der **Parallelism** -Iterator an der Grenze zwischen zwei Bereichen wird **Segment Repartition**genannt. Sowohl**Branch Repartition** als auch **Segment Repartition** sind logische Operatoren.|  
|Keine|**Broadcast**|**Broadcast** weist einen untergeordneten Knoten und *n* übergeordnete Knoten auf. **Broadcast** sendet die Eingabezeilen bei Bedarf an mehrere Consumer. Jeder Consumer erhält alle Zeilen. Wenn z.B. alle Consumer sich auf der Erstellungsseite eines Hashjoins befinden, werden *n* Kopien der Hashtabellen erstellt.|  
|![Build Hash-Operator (Symbol)](../relational-databases/media/build-hash.gif "Build Hash-Operator (Symbol)")|**Build Hash**|Gibt die Erstellung einer Batchhashtabelle für einen speicheroptimierten xVelocity-columnstore-Index an.|  
|Keine|**Cache**|**Cache** ist eine spezielle Version des **Spool** -Operators. Er speichert nur eine Datenzeile. **Cache** ist ein logischer Operator. **Cache** wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]nicht verwendet.|  
|![Clustered Index Delete-Operator (Symbol)](../relational-databases/media/clustered-index-delete-32x.gif "Clustered Index Delete-Operator (Symbol)")|**Clustered Index Delete**|Der **Clustered Index Delete** -Operator löscht Zeilen aus dem gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist. Wenn ein WHERE:()-Prädikat in der Argument-Spalte vorhanden ist, werden nur die Zeilen gelöscht, die das Prädikat erfüllen.**Clustered Index Delete** ist ein physischer Operator.|  
|![Clustered Index Insert-Operator (Symbol)](../relational-databases/media/clustered-index-insert-32x.gif "Clustered Index Insert-Operator (Symbol)")|**Clustered Index Insert**|Der **Clustered Index Insert** -Showplanoperator fügt die Eingabezeilen in den gruppierten Index ein, der in der Argument-Spalte angegeben ist. Die Argument-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. Wenn **Clustered Index Insert** keine untergeordneten Elemente für Eingabewerte enthält, wird die eingefügte Zeile aus dem **Insert** -Operator selbst übernommen.**Clustered Index Insert** ist ein physischer Operator.|  
|![Clustered Index Merge-Operator](../relational-databases/media/clustered-index-merge-32x.gif "Clustered Index Merge-Operator")|**Clustered Index Merge**|Der **Clustered Index Merge** -Operator übernimmt einen Mergedatenstrom für einen gruppierten Index. Der Operator löscht oder aktualisiert Zeilen aus dem gruppierten Index, der in der **Argument** -Spalte des Operators angegeben ist, bzw. fügt Zeilen in diesen ein. Der tatsächlich ausgeführte Vorgang ist vom Laufzeitwert der in der **Argument** -Spalte des Operators angegebenen **ACTION** -Spalte abhängig. **Clustered Index Merge** ist ein physischer Operator.|  
|![Clustered Index Scan-Operator (Symbol)](../relational-databases/media/clustered-index-scan-32x.gif "Clustered Index Scan-Operator (Symbol)")|**Clustered Index Scan**|Der **Clustered Index Scan** -Operator scannt den gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist. Wenn ein optionales WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. Wenn die Argument-Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor angefordert, dass die Ausgabe der Zeilen in der Reihenfolge zurückgegeben wird, in der sie vom gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, scannt das Speichermodul den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist). **Clustered Index Scan** ist ein logischer und physischer Operator.|  
|![Clustered Index Seek-Operator (Symbol)](../relational-databases/media/clustered-index-seek-32x.gif "Clustered Index Seek-Operator (Symbol)")|**Clustered Index Seek**|Der **Clustered Index Seek** -Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem gruppierten Index abzurufen. Die **Argument** -Spalte enthält den Namen des verwendeten gruppierten Indexes und das SEEK:()-Prädikat. Das Speichermodul verarbeitet mit diesem Index nur die Zeilen, die das SEEK:()-Prädikat erfüllen. Es kann auch ein WHERE:()-Prädikat einschließen, das das Speichermodul für alle Zeilen auswertet, die das SEEK:()-Prädikat erfüllen. Dies ist jedoch optional, und es werden keine Indizes für diesen Prozess verwendet.<br /><br /> Wenn die **Argument** -Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in der sie vom gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, durchsucht das Speichermodul den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist). Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe. Bei der Anzeige des LOOKUP-Schlüsselworts, wird ein Bookmark Lookup ausgeführt. In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] und höheren Versionen stellt der Operator **Key Lookup** die Bookmark Lookup-Funktionalität bereit. **Clustered Index Seek** ist ein logischer und physischer Operator.|  
|![Clustered Index Update-Operator (Symbol)](../relational-databases/media/clustered-index-update-32x.gif "Clustered Index Update-Operator (Symbol)")|**Clustered Index Update**|Der **Clustered Index Update** -Operator aktualisiert Eingabezeilen in dem gruppierten Index, der in der **Argument** -Spalte angegeben ist. Wenn ein WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen aktualisiert, die dieses Prädikat erfüllen. Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt. Wenn ein DEFINE:()-Prädikat vorhanden ist, werden die durch diesen Operator definierten Werte aufgelistet. Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie in dieser Abfrage verwiesen werden. **Clustered Index Update** ist ein logischer und physischer Operator.|  
|![Collapse-Operator (Symbol)](../relational-databases/media/collapse-32x.gif "Collapse-Operator (Symbol)")|**Reduzieren**|Der **Collapse** -Operator optimiert die Verarbeitung von Aktualisierungen. Eine Aktualisierung kann bei ihrer Ausführung mithilfe des **Split** -Operators in einen Lösch- und einen Einfügevorgang aufgeteilt werden. Die **Argument** -Spalte enthält eine GROUP BY:()-Klausel, die eine Liste von Schlüsselspalten angibt. Wenn der Abfrageprozessor benachbarte Zeilen erkennt, die dieselben Schlüsselwerte löschen und einfügen, werden diese separaten Vorgänge durch einen einzigen effektiveren Updatevorgang ersetzt. **Collapse** ist sowohl ein logischer als auch physischer Operator.|  
|![Columnstore-Indexscan](../relational-databases/media/columnstoreindexscan.gif "Columnstore-Indexscan")|**Columnstore-Indexscan**|Der **Columnstore Index Scan** -Operator scannt den columnstore-Index, der in der **Argument** -Spalte des Abfrageausführungsplans angegeben ist.|  
|![Compute Scalar-Operator (Symbol)](../relational-databases/media/compute-scalar-32x.gif "Compute Scalar-Operator (Symbol)")|**Compute Scalar**|Der **Compute Scalar** -Operator wertet einen Ausdruck aus und erstellt einen berechneten skalaren Wert. Dieser kann an den Benutzer zurückgegeben und/oder an anderer Stelle in der Abfrage als Verweis verwendet werden. Ein Beispiel für beide Fälle ist ein Filterprädikat oder Joinprädikat. **Compute Scalar** ist sowohl ein logischer als auch physischer Operator.<br /><br /> **Compute Scalar** -Operatoren in Showplans, die durch SET STATISTICS XML generiert wurden, enthalten eventuell nicht das **RunTimeInformation** -Element. In grafischen Showplans können **Tatsächliche Zeilen**, **Tatsächlich erneuerte Bindungen**und **Tatsächliche Zurückspulvorgänge** im Fenster **Eigenschaften** fehlen, wenn die Option **Tatsächlichen Ausführungsplan einschließen** in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]aktiviert wurde. Wenn diese Situation eintritt, bedeutet das, dass diese Operatoren zwar im kompilierten Abfrageplan verwendet wurden, ihre Arbeit jedoch von anderen Operatoren im Laufzeitabfrageplan verrichtet wurde. Beachten Sie außerdem, dass die Anzahl der Ausführungen in der von SET STATISTICS PROFILE generierten Showplanausgabe gleich der Summe der erneuten Bindungen und Zurückspulvorgänge in den von SET STATISTICS XML generierten Showplans ist.|  
|![Concatenation-Operator (Symbol)](../relational-databases/media/concatenation-32x.gif "Concatenation-Operator (Symbol)")|**Concatenation**|Der **Concatenation** -Operator scannt mehrere Eingaben und gibt die gescannten Zeilen zurück. **Concatenation** wird im Allgemeinen verwendet, um das [!INCLUDE[tsql](../includes/tsql-md.md)] -Konstrukt UNION ALL zu implementieren. Der physische Operator **Concatenation** verfügt über mindestens zwei Eingaben und eine Ausgabe. Concatenation kopiert Zeilen aus dem ersten Eingabedatenstrom in den Ausgabedatenstrom und wiederholt diese Operation anschließend für jeden weiteren Eingabedatenstrom. **Concatenation** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Constant Scan-Operator (Symbol)](../relational-databases/media/constant-scan-32x.gif "Constant Scan-Operator (Symbol)")|**Constant Scan**|Mithilfe des **Constant Scan** -Operators wird mindestens eine konstante Zeile in eine Abfrage eingeführt. Ein **Compute Scalar** -Operator wird häufig nach einem **Constant Scan** verwendet, um einer Zeile, die durch den **Constant Scan** -Operator erstellt wurde, Spalten hinzuzufügen.|  
|![Convert-Sprachelement (Datenbankmodul - Symbol)](../relational-databases/media/convert-32x.gif "Convert-Sprachelement (Datenbankmodul - Symbol)")|**Konvertieren**|Der **Convert** -Operator wandelt einen skalaren Datentyp in einen anderen um. **Convert** ist ein Sprachelement.|  
|Keine|**Cross Join**|Der **Cross Join** -Operator verknüpft jede Zeile der ersten (oberen) Eingabe mit jeder Zeile der zweiten (unteren) Eingabe. **Cross Join** ist ein logischer Operator.|  
|![Cursorsammelelement (Cursoroperatorsymbol)](../relational-databases/media/cursor-catch-all.gif "Cursorsammelelement (Cursoroperatorsymbol)")|**catchall**|Das Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachelemente).|  
|Keine|**Cursor**|Die logischen und physischen **Cursor** -Operatoren beschreiben, wie eine Abfrage oder Aktualisierung mit Cursoroperationen ausgeführt wird. Die physischen Operatoren beschreiben den Algorithmus, der für die physische Implementierung der Cursorverarbeitung verwendet wird, wie z. B. Verwenden eines keysetgesteuerten Cursors. Jeder Schritt bei der Ausführung eines Cursors benötigt einen physischen Operator. Die logischen Operatoren beschreiben eine Cursoreigenschaft, z. B. der Cursor ist schreibgeschützt.<br /><br /> Zu den logischen Operatoren zählen Asynchronous, Optimistic, Primary, Read Only, Scroll Locks sowie Secondary und Synchronous.<br /><br /> Zu den physischen Operatoren zählen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query und Snapshot.|  
|![Declare-Sprachelement (Symbol)](../relational-databases/media/declare-32x.gif "Declare-Sprachelement (Symbol)")|**Declare**|Der **Declare**  -Operator weist eine lokale Variable im Abfrageplan zu. **Declare** ist ein Sprachelement.|  
|![Delete-Operator (Datenbankmodul – Symbol)](../relational-databases/media/delete-32x.gif "Delete-Operator (Datenbankmodul – Symbol)")|**Delete**|Der **Delete** -Operator löscht aus einem Objekt alle Zeilen, die das optionale Prädikat in der **Argument** -Spalte erfüllen.|  
|![Delete Scan-Operator (Symbol)](../relational-databases/media/delete-scan-32x.gif "Delete Scan-Operator (Symbol)")|**Deleted Scan**|Der **Deleted Scan** -Operator scannt die deleted-Tabelle in einem Trigger.|  
|Keine|**Distinct**|Mithilfe des **Distinct** -Operators werden Duplikate aus einem Rowset oder aus einer Sammlung von Werten entfernt. **Distinct** ist ein logischer Operator.|  
|Keine|**Distinct Sort**|Der logische Operator **Distinct Sort** scannt die Eingabe, entfernt Duplikate und sortiert nach den Spalten, die im DISTINCT ORDER BY:()-Prädikat der **Argument** -Spalte angegeben sind. **Distinct Sort** ist ein logischer Operator.|  
|![Distribute Streams Parallelism-Operator (Symbol)](../relational-databases/media/parallelism-distribute-stream.gif "Distribute Streams Parallelism-Operator (Symbol)")|**Distribute Streams**|Der **Distribute Streams** -Operator wird nur in parallelen Abfrageplänen verwendet. Der **Distribute Streams** -Operator nimmt genau einen Eingabedatenstrom von Datensätzen an und erzeugt mehrere Ausgabedatenströme. Inhalt und Format der Datensätze werden nicht geändert. Jeder Datensatz aus dem Eingabedatenstrom wird in genau einem der Ausgabedatenströme angezeigt. Dieser Operator behält die relative Reihenfolge der Eingabedatensätze in den Ausgabedatenströmen bei. In der Regel wird mit einem Hashingverfahren festgelegt, zu welchem Ausgabedatenstrom ein bestimmter Eingabedatensatz gehört.<br /><br /> Wenn die Ausgabe partitioniert ist, enthält die **Argument** -Spalte ein PARTITION COLUMNS:()-Prädikat und die Partitionierungsspalten. **Distribute Streams** ist ein logischer Operator.|  
|![Dynamic-Cursoroperator (Symbol)](../relational-databases/media/dynamic-32x.gif "Dynamic-Cursoroperator (Symbol)")|**Dynamic**|Der **Dynamic** -Operator verwendet einen Cursor, der alle von anderen vorgenommenen Änderungen wahrnimmt.|  
|![Spool-Operator (Symbol)](../relational-databases/media/spool-32x.gif "Spool-Operator (Symbol)")|**Eager Spool**|Der **Eager Spool** -Operator verarbeitet die gesamte Eingabe und speichert jede Zeile in einem verborgenen temporären Objekt in der **tempdb** -Datenbank. Wenn der Operator zurückgesetzt wird (beispielsweise aufgrund eines **Nested Loops** -Operators), aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt. Der **Eager Spool** -Operator erstellt seine Spooldatei unverzüglich: Wenn der übergeordnete Operator des Spoolvorgangs die erste Zeile anfordert, verarbeitet der Spool-Operator alle Zeilen aus dem Eingabeoperator und speichert sie im Spool. **Eager Spool** ist ein logischer Operator.|  
|![Fetch Query-Cursoroperator (Symbol)](../relational-databases/media/fetch-query-32x.gif "Fetch Query-Cursoroperator (Symbol)")|**Fetch Query**|Der **Fetch Query** -Operator ruft Zeilen ab, wenn eine Abrufoperation für einen Cursor ausgegeben wird.|  
|![Filter-Operator (Datenbankmodul - Symbol)](../relational-databases/media/filter-32x.gif "Filter-Operator (Datenbankmodul - Symbol)")|**Filter**|Der **Filter** -Operator scannt die Eingabe und gibt nur die Zeilen zurück, die den in der **Argument** -Spalte angezeigten Filterausdruck (Prädikat) erfüllen.|  
|Keine|**Flow Distinct**|Der logische Operator **Flow Distinct** scannt die Eingabe und entfernt Duplikate. Während der **Distinct** -Operator zuerst die gesamte Eingabe verarbeitet und dann die Ausgabe erstellt, gibt der **FlowDistinct** -Operator die Eingabe zeilenweise zurück (ausgenommen sind Zeilenduplikate, da diese entfernt werden).|  
|Keine|**Full Outer Join**|Der logische **Full Outer Join** -Operator gibt alle Zeilen zurück, die das JOIN-Prädikat aus der ersten (oberen) Eingabe, verknüpft mit jeder Zeile aus der zweiten (unteren) Eingabe, erfüllen. Er gibt außerdem die folgenden Zeilen zurück:<br /><br /> – Zeilen aus der ersten Eingabe, für die in der zweiten Eingabe keine Übereinstimmung besteht.<br /><br /> – Zeilen aus der zweiten Eingabe, für die in der ersten Eingabe keine Übereinstimmung besteht.<br /><br /> Eingaben, die keine übereinstimmenden Werte enthalten, werden als NULL-Wert zurückgegeben. **Full Outer Join** ist ein logischer Operator.|  
|![Gather Streams Parallelism-Operator (Symbol)](../relational-databases/media/parallelism-32x.gif "Gather Streams Parallelism-Operator (Symbol)")|**Gather Streams**|Der **Gather Streams** -Operator wird nur in parallelen Abfrageplänen verwendet. Der **Gather Streams** -Operator verarbeitet mehrere Eingabedatenströme, fasst diese zusammen und erzeugt genau einen Ausgabedatenstrom von Datensätzen. Inhalt und Format der Datensätze werden nicht geändert. Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen. Wenn die Ausgabe sortiert ist, enthält die **Argument** -Spalte ein ORDER BY:()-Prädikat und die Namen der zu sortierenden Spalten. **Gather Streams** ist ein logischer Operator.|  
|![Hash Match-Operator (Symbol)](../relational-databases/media/hash-match-32x.gif "Hash Match-Operator (Symbol)")|**Hash Match**|Der **Hash Match** -Operator erzeugt eine Hashtabelle, indem er für jede Zeile der Erstellungseingabe einen Hashwert berechnet. Ein HASH:()-Prädikat mit einer Liste der Spalten, die zum Erstellen der Hashwerte verwendet werden, wird in der **Argument** -Spalte angezeigt. Anschließend wird, soweit möglich, für jede Einfügezeile ein Hashwert (mithilfe derselben Hashfunktion) berechnet und in der Hashtabelle nach Übereinstimmungen gesucht. Wenn ein RESIDUAL-Prädikat vorhanden ist (identifiziert durch RESIDUAL:() in der **Argument** -Spalte), müssen Zeilen auch dieses Prädikat erfüllen, um als übereinstimmend zu gelten. Das Verhalten des Operators hängt von dem auszuführenden logischen Vorgang ab:<br /><br /> – Für jeden Join wird die erste (obere) Eingabe verwendet, um die Hashtabelle zu erstellen, und die zweite (untere) Eingabe zum Einfügen in die Hashtabelle. Die Ausgabeübereinstimmungen (oder Nichtübereinstimmungen) werden vom Jointyp bestimmt. Wenn mehrere Joins dieselbe Joinspalte verwenden, werden diese Vorgänge in einem Hashteam gruppiert.<br /><br /> – Für die Operatoren Distinct oder Aggregate wird die Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt und Aggregatausdrücke berechnet werden). Wenn die Hashtabelle erstellt ist, wird die Tabelle gescannt, und alle Einträge werden ausgegeben.<br /><br /> – Für den Union-Operator wird die erste Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt werden). Die zweite Eingabe (die keine Duplikate haben darf) wird zum Einfügen in die Hashtabelle verwendet, wobei alle nicht übereinstimmenden Zeilen zurückgegeben werden, anschließend wird die Hashtabelle gescannt, und alle Einträge werden zurückgegeben.<br /><br /> Der**Hash Match** -Operator ist ein physischer Operator.|  
|![If-Sprachelement (Symbol)](../relational-databases/media/if-32x.gif "If-Sprachelement (Symbol)")|**Wenn**|Der **If** -Operator führt eine bedingte Verarbeitung basierend auf einem Ausdruck aus. **If** ist ein Sprachelement.|  
|Keine|**Inner Join**|Der logische **Inner Join** -Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen.|  
|![Insert (Datenbankmodul - Operatorsymbol)](../relational-databases/media/insert-32x.gif "Insert (Datenbankmodul - Operatorsymbol)")|**Insert**|Der logische Operator **Insert** fügt alle Eingabezeilen in das Objekt ein, das in der **Argument** -Spalte angegeben ist. Der physische Operator ist entweder der **Table Insert**-, **Index Insert**- oder **Clustered Index Insert** -Operator.|  
|![Inserted Scan-Operator (Symbol)](../relational-databases/media/inserted-scan-32x.gif "Inserted Scan-Operator (Symbol)")|**Inserted Scan**|Der **Inserted Scan** -Operator scannt die **inserted** -Tabelle. **Inserted Scan** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Intrinsic-Sprachelement (Symbol)](../relational-databases/media/intrinsic-32x.gif "Intrinsic-Sprachelement (Symbol)")|**Intrinsic**|Der **Intrinsic** -Operator ruft eine interne [!INCLUDE[tsql](../includes/tsql-md.md)] -Funktion auf. **Intrinsic** ist ein Sprachelement.|  
|![Iteratorsammelelement (Operatorsymbol)](../relational-databases/media/iterator-catch-all.gif "Iteratorsammelelement (Operatorsymbol)")|**Iterator**|Das **Iterator** -Sammelsymbol wird angezeigt, wenn die Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator finden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).|  
|![Bookmark Lookup-Operator (Symbol)](../relational-databases/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")|**Key Lookup**|Der **Key Lookup** -Operator stellt eine Lesezeichensuche für eine Tabelle mit einem gruppierten Index dar. Die **Argument** -Spalte enthält den Namen des gruppierten Indexes und den Gruppierungsschlüssel, der für die Suche nach der Zeile im gruppierten Index verwendet wird. **Key Lookup** wird stets von einem **Nested Loops** -Operator begleitet. Wenn die WITH PREFETCH-Klausel in der **Argument** -Spalte auftritt, wurde vom Abfrageprozessor ermittelt, dass Lesezeichen im gruppierten Index am besten mit asynchronem Vorauslesen (Read-Ahead) nachgeschlagen werden sollten.<br /><br /> Durch die Verwendung eines **Key Lookup** -Operators in einem Abfrageplan wird angegeben, dass für die Abfrage eine Leistungsoptimierung von Vorteil sein könnte. Beispielsweise kann die Leistung durch Hinzufügen eines abdeckenden Indexes optimiert werden.|  
|![Keyset-Cursoroperator (Symbol)](../relational-databases/media/keyset-32x.gif "Keyset-Cursoroperator (Symbol)")|**Keyset**|Der **Keyset** -Operator verwendet einen Cursor, für den Aktualisierungen sichtbar sind, jedoch keine von anderen vorgenommenen Einfügungen.|  
|![Sprachsammelelement (Symbol)](../relational-databases/media/language-construct-catch-all.gif "Sprachsammelelement (Symbol)")|**Language-Element**|Das **Language Element** -Sammelsymbol wird angezeigt, wenn die Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator finden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).|  
|![Spool-Operator (Symbol)](../relational-databases/media/spool-32x.gif "Spool-Operator (Symbol)")|**Lazy Spool**|Der logische Operator **Lazy Spool** speichert alle Zeilen aus der Eingabe in einem verborgenen temporären Objekt in der **tempdb** -Datenbank. Wenn der Operator zurückgesetzt wird (beispielsweise aufgrund eines **Nested Loops** -Operators), aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt. Der **Lazy Spool** -Operator erstellt seine Spooldatei mit Verzögerung. Das bedeutet, dass der Spooloperator jedes Mal, wenn der übergeordnete Operator des Spoolvorgangs eine Zeile anfordert, eine Zeile aus seinem Eingabeoperator erhält und sie im Spool speichert, anstatt alle Zeilen gleichzeitig zu verarbeiten. Lazy Spool ist ein logischer Operator.|  
|Keine|**Left Anti Semi Join**|Der **Left Anti Semi Join** -Operator gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist. Wenn kein Joinprädikat in der **Argument** -Spalte vorhanden ist, stellt jede Zeile eine übereinstimmende Zeile dar. **Left Anti Semi Join** ist ein logischer Operator.|  
|Keine|**Left Outer Join**|Der **Left Outer Join** -Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen. Er gibt auch alle Zeilen aus der ersten Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten Eingabe vorhanden ist. Die nicht übereinstimmenden Zeilen in der zweiten Eingabe werden als NULL-Werte zurückgegeben. Wenn kein Joinprädikat in der **Argument** -Spalte vorhanden ist, stellt jede Zeile eine übereinstimmende Zeile dar. **Left Outer Join** ist ein logischer Operator.|  
|Keine|**Left Semi Join**|Der **Left Semi Join** -Operator gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die eine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist. Wenn kein Joinprädikat in der **Argument** -Spalte vorhanden ist, stellt jede Zeile eine übereinstimmende Zeile dar. **Left Semi Join** ist ein logischer Operator.|  
|![Log Row Scan-Operator (Symbol)](../relational-databases/media/log-row-scan-32x.gif "Log Row Scan-Operator (Symbol)")|**Log Row Scan**|Der **Log Row Scan** -Operator scannt das Transaktionsprotokoll. **Log Row Scan** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Merge Interval-Operator (Symbol)](../relational-databases/media/merge-interval-32x.gif "Merge Interval-Operator (Symbol)")|**Merge Interval**|Der Operator **Merge Interval** führt mehrere (möglicherweise überlappende) Intervalle zusammen, um minimale, nicht überlappende Intervalle zu erzeugen, die anschließend zum Suchen von Indexeinträgen verwendet werden. Dieser Operator erscheint in der Regel über einem oder mehreren **Compute Scalar** -Operatoren, die wiederum über **Constant Scan** -Operatoren erscheinen, welche die von diesem Operator (als Spalten in einer Zeile dargestellten) zu mischenden Intervalle aufbauen. **Merge Interval** ist sowohl ein logischer als auch physischer Operator.|  
|![Merge Join-Operator (Symbol)](../relational-databases/media/merge-join-32x.gif "Merge Join-Operator (Symbol)")|**Merge Join**|Der **Merge Join** -Operator führt die logischen Vorgänge „innere Verknüpfung“, „linke äußere Verknüpfung“, „linke Semiverknüpfung“, „linke Antisemiverknüpfung“, „rechte äußere Verknüpfung“, „rechte Semiverknüpfung“, „rechte Antisemiverknüpfung“ und „Vereinigung“ aus.<br /><br /> In der **Argument** -Spalte enthält der **Merge Join** -Operator ein MERGE:()-Prädikat, wenn der Vorgang einen 1:n-Join ausführt, oder ein MANY-TO-MANY MERGE:()-Prädikat, wenn der Vorgang einen m:n-Join ausführt. Die **Argument** -Spalte schließt auch eine durch Trennzeichen getrennte Liste der Spalten ein, die bei der Ausführung des Vorgangs verwendet wurden. Der **Merge Join** -Operator benötigt zwei Eingaben, die nach den jeweiligen Spalten sortiert sind, möglicherweise durch Einfügen von expliziten Sortiervorgängen in den Abfrageplan. Ein Zusammenführungsjoin ist vor allem effizient, wenn kein expliziter Sortiervorgang erforderlich ist, beispielsweise wenn ein geeigneter B-Struktur-Index in der Datenbank vorhanden ist oder die Datenbank für mehrere Vorgänge, z. B. ein Zusammenführungsjoin und Gruppierung mit Rollup, verwendet werden kann. Bei**Merge Join** handelt es sich um einen physischen Operator.|  
|![Nested Loops-Operator (Symbol)](../relational-databases/media/nested-loops-32x.gif "Nested Loops-Operator (Symbol)")|**Nested Loops**|Der **Nested Loops** -Operator führt die logischen Operationen „innere Verknüpfung“, „linke äußere Verknüpfung“, „linke Semiverknüpfung“ und „linke Antisemiverknüpfung“ aus. Nested Loops-Joins führen für jede Zeile der äußeren Tabelle eine Suche in der inneren Tabelle aus, in der Regel mithilfe eines Indexes. Der Abfrageprozessor legt auf der Grundlage der geschätzten Kosten fest, ob die äußere Eingabe sortiert werden soll, um die Treffsicherheit der Suchvorgänge auf dem Index über die innere Eingabe zu verbessern. Alle Zeilen, die das (optionale) Prädikat in der **Argument** -Spalte erfüllen, werden auf der Grundlage der ausgeführten logischen Operation als anwendbar zurückgegeben. **Nested Loops** ist ein physischer Operator.|  
|![Nonclustered Index Delete-Operator (Symbol)](../relational-databases/media/nonclust-index-delete-32x.gif "Nonclustered Index Delete-Operator (Symbol)")|**Nonclustered Index Delete**|Der Operator **Nonclustered Index Delete** löscht Eingabezeilen aus dem in der **Argument** -Spalte angegebenen nicht gruppierten Index. **Nonclustered Index Delete** ist ein physischer Operator.|  
|![Nonclustered Index Insert-Operator (Symbol)](../relational-databases/media/nonclust-index-insert-32x.gif "Nonclustered Index Insert-Operator (Symbol)")|**Index Insert**|Mithilfe des **Index Insert** -Operators werden Zeilen aus der Eingabe in den nicht gruppierten Index eingegeben, der in der **Argument** -Spalte angegeben ist. Die **Argument** -Spalte enthält auch ein SET:()-Prädikat, mit dem der Wert angegeben wird, auf den die einzelnen Spalten festgelegt sind. **Index Insert** ist ein physischer Operator.|  
|![Nonclustered Index Scan-Operator (Symbol)](../relational-databases/media/nonclustered-index-scan-32x.gif "Nonclustered Index Scan-Operator (Symbol)")|**Index Scan**|Der **Index Scan** -Operator ruft alle Zeilen des nicht gruppierten Indexes ab, der in der **Argument** -Spalte angegeben ist. Wenn ein optionales WHERE:()-Prädikat in der **Argument** -Spalte vorhanden ist, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. **Index Scan** ist ein logischer und physischer Operator.|  
|![Nonclustered Index Seek-Operator (Symbol)](../relational-databases/media/index-seek-32x.gif "Nonclustered Index Seek-Operator (Symbol)")|**Index Seek**|Der **Index Seek** -Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem nicht gruppierten Index abzurufen. Die **Argument** -Spalte enthält den Namen des verwendeten nicht gruppierten Indexes. Außerdem enthält sie auch das SEEK:()-Prädikat. Mit diesem Index werden vom Speichermodul nur die Zeilen verarbeitet, die das SEEK:()-Prädikat erfüllen. Optional kann ein WHERE:()-Prädikat enthalten sein, das vom Speichermodul für alle Zeilen ausgewertet wird, bei denen das SEEK:()-Prädikat erfüllt wird (es werden hierfür keine Indizes verwendet). Wenn die **Argument** -Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in der sie vom nicht gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, so durchsucht das Speichermodul den Index auf die optimale Art (wobei die Ausgabe nicht unbedingt sortiert ist). Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe. **Index Seek** ist ein logischer und physischer Operator.|  
|![Nonclustered Index Spool-Operator (Symbol)](../relational-databases/media/index-spool-32x.gif "Nonclustered Index Spool-Operator (Symbol)")|**Index Spool**|Der physische Operator **Index Spool** enthält ein SEEK:()-Prädikat in der **Argument** -Spalte. Der physische **Index Spool** -Operator scannt die Eingabezeilen, platziert eine Kopie jeder Zeile in einer verborgenen Spooldatei (die in der **tempdb** -Datenbank gespeichert und nur für die Lebensdauer der Abfrage vorhanden ist) und erstellt einen nicht gruppierten Index für die Zeilen. Dies ermöglicht es Ihnen, mithilfe der Indexsuchfunktionen nur die Zeilen auszugeben, die das SEEK:()-Prädikat erfüllen. Wenn der Operator zurückgesetzt wird (beispielsweise aufgrund eines **Nested Loops** -Operators), aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.|  
|![Nonclustered Index Update-Operator (Symbol)](../relational-databases/media/nonclust-index-update-32x.gif "Nonclustered Index Update-Operator (Symbol)")|**Nonclustered Index Update**|Der physische Operator **Nonclustered Index Update** aktualisiert Eingabezeilen in dem nicht gruppierten Index, der in der **Argument** -Spalte angegeben ist. Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt. **Nonclustered Index Update** ist ein physischer Operator.|  
|![Online Index Insert-Operator (Symbol)](../relational-databases/media/online-index-32x.gif "Online Index Insert-Operator (Symbol)")|**Online Index Insert**|Der physische Operator **Online Index Insert** gibt an, dass ein Index online erstellt, geändert oder gelöscht wird. Die zugrunde liegenden Tabellendaten bleiben daher während des Indexvorgangs für Benutzer verfügbar.|  
|Keine|**Parallelism**|Der **Parallelism** -Operator führt die logischen Operationen Distribute Streams, Gather Streams und Repartition Streams durch. Die **Argument** -Spalten können ein PARTITION COLUMNS:()-Prädikat mit einer durch Trennzeichen getrennten Liste der zu partitionierenden Spalten enthalten. Außerdem können die **Argument** -Spalten ein ORDER BY:()-Prädikat enthalten, das durch Auflisten der Spalten die Sortierreihenfolge bei der Partitionierung beibehält. **Parallelism** ist ein physischer Operator.<br /><br /> <br /><br /> Hinweis: Wenn eine Abfrage als parallele Abfrage kompiliert wurde, aber zur Laufzeit als serielle Abfrage ausgeführt wird, enthält die entweder mit SET STATISTICS XML oder mit der Option **Tatsächlichen Ausführungsplan einschließen** von [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] generierte Showplanausgabe kein **RunTimeInformation** -Element für den **Parallelism** -Operator. In der SET STATISTICS PROFILE-Ausgabe werden für die tatsächliche Anzahl der Zeilen sowie die tatsächliche Anzahl der Ausführungen Nullen für den **Parallelism** -Operator angezeigt. Tritt eine der Bedingungen auf, bedeutet dies, dass der **Parallelism** -Operator nur während der Kompilierung der Abfrage, nicht aber im Laufzeitabfrageplan verwendet wurde. Beachten Sie, dass parallele Abfragepläne mitunter seriell ausgeführt werden, wenn der Server stark ausgelastet ist.|  
|![Parameter Table Scan-Operator (Symbol)](../relational-databases/media/parameter-table-scan-32x.gif "Parameter Table Scan-Operator (Symbol)")|**Parameter Table Scan**|Der **Parameter Table Scan** -Operator scannt eine Tabelle, die als Parameter in der aktuellen Abfrage dient. In der Regel wird dieser Operator für INSERT-Abfragen in einer gespeicherten Prozedur verwendet. **Parameter Table Scan** ist ein logischer und physischer Operator.|  
|Keine|**Partial Aggregate**|**Partial Aggregate** wird in parallelen Plänen verwendet. Hiermit wird eine Aggregatfunktion auf möglichst viele Eingabezeilen angewandt, damit das Schreiben auf den Datenträger (der so genannte "Überlauf") nicht erforderlich ist. **Hash Match** ist der einzige physische Operator (Iterator), der die Partitionsaggregation implementiert. **Partial Aggregate** ist ein logischer Operator.|  
|![Population Query-Cursoroperator (Symbol)](../relational-databases/media/poulation-query-32x.gif "Population Query-Cursoroperator (Symbol)")|**Population Query**|Der **Population Query** -Operator füllt die Arbeitstabelle eines Cursors auf, wenn der Cursor geöffnet wird.|  
|![Refresh Query-Cursoroperator (Symbol)](../relational-databases/media/refresh-query-32x.gif "Refresh Query-Cursoroperator (Symbol)")|**Refresh Query**|Der **Refresh Query** -Operator ruft aktuelle Daten für die Zeilen im Fetchpuffer ab.|  
|![Remote Delete-Operator (Symbol)](../relational-databases/media/remote-delete-32x.gif "Remote Delete-Operator (Symbol)")|**Remote Delete**|Der **Remote Delete** -Operator löscht die Eingabezeilen in einem Remoteobjekt. **Remote Delete** ist ein logischer und physischer Operator.|  
|![Remote Index Seek-Showplanoperator](../relational-databases/media/remote-index-scan-32x.gif "Remote Index Seek-Showplanoperator")|**Remote Index Scan**|Der **Remote Index Scan** -Operator durchsucht den in der Argumentspalte angegebenen Remoteindex. **Remote Index Scan** ist ein logischer und physischer Operator.|  
|![Remote Index Seek-Showplanoperator](../relational-databases/media/remote-index-seek-32x.gif "Remote Index Seek-Showplanoperator")|**Remote Index Seek**|Der **Remote Index Seek** -Operator verwendet die Suchmöglichkeiten eines Remoteindexobjekts, um Zeilen abzurufen. Die **Argument** -Spalte enthält den Namen des verwendeten Remoteindexes und das SEEK:()-Prädikat. **Remote Index Seek** ist ein logischer und physischer Operator.|  
|![Remote Insert-Operator (Symbol)](../relational-databases/media/remote-insert-32x.gif "Remote Insert-Operator (Symbol)")|**Remote Insert**|Der **Remote Insert** -Operator fügt die Eingabezeilen in ein Remoteobjekt ein. **Remote Insert** ist ein logischer und physischer Operator.|  
|![Remote Query-Operator (Symbol)](../relational-databases/media/remote-query-32x.gif "Remote Query-Operator (Symbol)")|**Remote Query**|Durch den Operator **Remote Query** wird eine Abfrage an eine Remotequelle übermittelt. Der Text der an den Remoteserver gesendeten Abfrage wird in der **Argument** -Spalte angezeigt. **Remote Query** ist ein logischer und physischer Operator.|  
|![Remote Scan-Operator (Symbol)](../relational-databases/media/remote-scan-32x.gif "Remote Scan-Operator (Symbol)")|**Remote Scan**|Der Operator **Remote Scan** überprüft ein Remoteobjekt. Der Name des Remoteobjekts wird in der **Argument-Spalte** angezeigt. **Remote Scan** ist ein logischer und physischer Operator.|  
|![Remote Update-Operator (Symbol)](../relational-databases/media/remote-update-32x.gif "Remote Update-Operator (Symbol)")|**Remote Update**|Der **Remote Update** -Operator aktualisiert die Eingabezeilen in einem Remoteobjekt. **Remote Update** ist ein logischer und physischer Operator.|  
|![Repartition Streams Parallelism-Operator (Symbol)](../relational-databases/media/parallelism-repartition-stream.gif "Repartition Streams Parallelism-Operator (Symbol)")|**Repartition Streams**|Der **Repartition Streams** -Operator verarbeitet und generiert mehrere Datenströme von Datensätzen. Inhalt und Format der Datensätze werden nicht geändert. Wenn der Abfrageoptimierer einen Bitmapfilter verwendet, wird die Anzahl der Zeilen im Ausgabedatenstrom reduziert. Jeder Datensatz aus einem Eingabedatenstrom wird in einem Ausgabedatenstrom platziert. Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen und in mehrere geordnete Ausgabedatenströme zusammengeführt werden. Wenn die Ausgabe partitioniert wurde, enthält die **Argument** -Spalte ein PARTITION COLUMNS:()-Prädikat sowie die Partitionierungsspalten. Wenn die Ausgabe sortiert wurde, enthält die **Argument** -Spalte ein ORDER BY:()-Prädikat und die sortierten Spalten. **Repartition Streams** ist ein logischer Operator. Der Operator wird nur in parallelen Abfrageplänen verwendet.|  
|![Result-Sprachelement (Symbol)](../relational-databases/media/result-32x.gif "Result-Sprachelement (Symbol)")|**Ergebnis**|Der **Result** -Operator stellt die Daten dar, die am Ende eines Abfrageplans zurückgegeben werden. Dies ist normalerweise das Stammelement eines Showplans. **Result** ist ein Sprachelement.|  
|![RID Lookup-Operator (Symbol)](../relational-databases/media/rid-nonclust-locate-32x.gif "RID Lookup-Operator (Symbol)")|**RID Lookup**|**RID Lookup** ist ein Bookmark Lookup für einen Heap, der eine bereitgestellte Zeilen-ID (RID) verwendet. Die **Argument** -Spalte enthält die Lesezeichenbeschriftung, mit der die Zeile in der Tabelle nachgeschlagen wird, und den Namen der Tabelle, in der die Zeile nachgeschlagen wird. **RID Lookup** wird stets durch eine NESTED LOOP JOIN-Anweisung begleitet. **RID Lookup** ist ein physischer Operator. Weitere Informationen zu Bookmark Lookups finden Sie unter „[Bookmark Lookup](http://go.microsoft.com/fwlink/?LinkId=132568)“ im SQL Server-Blog von MSDN.|  
|Keine|**Right Anti Semi Join**|Der logische Operator **Right Anti Semi Join** gibt alle Zeilen aus der zweiten (unteren) Eingabe aus, für die keine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist. Eine Zeile ist als übereinstimmende Zeile definiert, wenn das Prädikat in der **Argument** -Spalte erfüllt wird (bei fehlendem Prädikat sind alle Zeilen übereinstimmende Zeilen). **Right Anti Semi Join** ist ein logischer Operator.|  
|Keine|**Right Outer Join**|Der **Right Outer Join** -Operator gibt alle Zeilen zurück, die den Join der zweiten (unteren) Eingabe mit der ersten (oberen) Eingabe erfüllen. Er gibt auch alle Zeilen aus der zweiten Eingabe mit NULL-Werten zurück, für die keine übereinstimmende Zeile in der ersten Eingabe vorhanden ist. Wenn kein Joinprädikat in der **Argument** -Spalte vorhanden ist, stellt jede Zeile eine übereinstimmende Zeile dar. **Right Outer Join** ist ein logischer Operator.|  
|Keine|**Right Semi Join**|Der **Right Semi Join** -Operator gibt alle Zeilen aus der zweiten (unteren) Eingabe zurück, für die eine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist. Wenn kein Joinprädikat in der **Argument** -Spalte vorhanden ist, stellt jede Zeile eine übereinstimmende Zeile dar. **Right Semi Join** ist ein logischer Operator.|  
|![Row Count Spool-Operator (Symbo)l](../relational-databases/media/remote-count-spool-32x.gif "Row Count Spool-Operator (Symbol)")|**Row Count Spool**|Der **Row Count Spool** -Operator scannt die Eingabe, zählt, wie viele Zeilen vorhanden sind, und gibt dieselbe Anzahl an leeren Zeilen zurück. Dieser Operator wird verwendet, wenn es darauf ankommt, die Existenz von Zeilen und nicht ihren Inhalt zu überprüfen. Wenn beispielsweise ein **Nested Loops** -Operator einen Left Semi Join-Vorgang ausführt, wobei das Joinprädikat auf die innere Eingabe angewendet wird, kann ein Row Count Spool-Operator ganz am Anfang der inneren Eingabe des **Nested Loops** -Operators platziert werden. Anschließend kann der **Nested Loops** -Operator bestimmen, wie viele Zeilen vom Row Count Spool-Operator ausgegeben wurden (die inneren Daten werden hierzu nicht benötigt), um zu ermitteln, ob die äußere Zeile zurückgegeben werden muss. Beim**Row Count Spool** -Operator handelt es sich um einen physischen Operator.|  
|![Segment-Operator (Symbol)](../relational-databases/media/segment-32x.gif "Segment-Operator (Symbol)")|**Segment**|**Segment** ist ein physischer und logischer Operator. Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf. Diese Spalten werden als Argumente im Operator **Segment** angezeigt. Anschließend gibt der Operator ein Segment nach dem anderen aus.|  
|Keine|**Segment Repartition**|Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten. Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden. Die Bereiche selbst müssen seriell ausgeführt werden. Bestimmte **Parallelism** -Iteratoren innerhalb eines einzelnen Bereichs werden **Branch Repartition**genannt. Der **Parallelism** -Iterator an der Grenze zwischen zwei Bereichen wird **Segment Repartition**genannt. Sowohl**Branch Repartition** als auch **Segment Repartition** sind logische Operatoren.|  
|![Sequence-Operator (Symbol)](../relational-databases/media/sequence-32x.gif "Sequence-Operator (Symbol)")|**Sequenz**|Der **Sequence** -Operator steuert umfangreiche Aktualisierungspläne. Er führt die Eingaben sequenziell aus (von oben nach unten). Jede Eingabe stellt in der Regel ein Update eines anderen Objekts dar. Der Operator gibt nur die Zeilen zurück, die aus der letzten (unteren) Eingabe stammen. **Sequence** ist sowohl ein logischer als auch physischer Operator.|  
|![Sequence Project-Operator (Symbol)](../relational-databases/media/sequence-project-32x.gif "Sequence Project-Operator (Symbol)")|**Sequence Project**|Der **Sequence Project** -Operator fügt Spalten hinzu, um für eine geordnete Menge Berechnungen auszuführen. Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf. Anschließend gibt der Operator ein Segment nach dem anderen aus. Diese Spalten werden als Argumente im Operator **Sequence Project** angezeigt. **Sequence Project** ist ein logischer und physischer Operator.|  
|![Momentaufnahme-Cursoroperator (Symbol)](../relational-databases/media/snapshot-32x.gif "Momentaufnahme-Cursoroperator (Symbol)")|**Momentaufnahme**|Mit dem **Snapshot** -Operator wird ein Cursor erstellt, der von anderen vorgenommene Änderungen nicht wahrnimmt.|  
|![Sort-Operator (Symbol)](../relational-databases/media/sort-32x.gif "Sort-Operator (Symbol)")|**Sort**|Der **Sort** -Operator sortiert alle eingehenden Zeilen. Die **Argument** -Spalte enthält entweder ein DISTINCT ORDER BY:()-Prädikat, wenn Duplikate aus dieser Operation entfernt werden sollen, oder sie enthält ein ORDER BY:()-Prädikat mit einer durch Trennzeichen getrennten Liste der zu sortierenden Spalten. Die Spalten werden mit dem Präfix ASC versehen, wenn sie in aufsteigender Reihenfolge sortiert werden, oder mit der Zeichenfolge DESC, wenn sie in absteigender Reihenfolge sortiert werden. **Sort** ist ein logischer und physischer Operator.|  
|![Split-Operator (Symbol)](../relational-databases/media/split-32x.gif "Split-Operator (Symbol)")|**Split**|Der **Split** -Operator wird zum Optimieren der Aktualisierungsverarbeitung verwendet. Er teilt jeden Aktualisierungsvorgang in einen Lösch- und einen Einfügevorgang auf. **Split** ist ein logischer und physischer Operator.|  
|![Spool-Operator (Symbol)](../relational-databases/media/spool-32x.gif "Spool-Operator (Symbol)")|**Spool**|Mit dem **Spool** -Operator wird ein Zwischenabfrageergebnis in die **tempdb** -Datenbank geschrieben.|  
|![Stream Aggregate-Operator (Symbol)](../relational-databases/media/stream-aggregate-32x.gif "Stream Aggregate-Operator (Symbol)")|**Stream Aggregate**|Der **Stream Aggregate** -Operator gruppiert Zeilen nach einer oder mehreren Spalten und berechnet einen oder mehrere Aggregatausdrücke, die von der Abfrage zurückgegeben wurden. Auf die Ausgabe dieses Operators kann durch spätere Operatoren in der Abfrage verwiesen werden, die Ausgabe kann an den Client zurückgegeben werden oder beides. Für den **Stream Aggregate** -Operator muss die Eingabe innerhalb der Gruppen nach den Spalten sortiert sein. Der Optimierer verwendet vor diesem Operator einen **Sort** -Operator, wenn die Daten nicht bereits durch einen vorherigen **Sort** -Operator oder durch einen geordneten Indexsuch- oder Scanvorgang sortiert wurden. In der SHOWPLAN_ALL-Anweisung oder im grafischen Ausführungsplan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]sind die Spalten im GROUP BY-Prädikat in der Spalte **Argument** aufgelistet, und die Aggregatausdrücke sind in der Spalte **Defined Values** aufgelistet. **Stream Aggregate** ist ein physischer Operator.|  
|![Switch-Operator (Symbol)](../relational-databases/media/switch-32x.gif "Switch-Operator (Symbol)")|**Schalter**|**Switch** ist ein spezieller Verkettungsiterator, der über *n* Eingaben verfügt. Mit jedem **Switch** -Operator ist ein Ausdruck verbunden. Abhängig vom Rückgabewert des Ausdrucks (zwischen 0 und *n*-1) kopiert **Switch** den entsprechenden Eingabedatenstrom in den Ausgabedatenstrom. Eine Verwendungsmöglichkeit von **Switch** besteht in der Implementierung von Abfrageplänen, die schnelle Vorwärtscursor mit bestimmten Operatoren, z.B. dem **TOP** -Operator, enthalten. **Switch** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Table Delete-Operator (Symbol)r](../relational-databases/media/table-delete-32x.gif "Table Delete-Operator (Symbol)")|**Table Delete**|Mit dem physischen Operator **Table Delete** werden Zeilen aus der in der **Argument** -Spalte angegebenen Tabelle des Abfrageausführungsplans gelöscht.|  
|![Table Insert-Operator (Symbol)](../relational-databases/media/table-insert-32x.gif "Table Insert-Operator (Symbol)")|**Table Insert**|Durch den Operator **Table Insert** werden Eingabezeilen in die in der **Argument** -Spalte des Abfrageausführungsplans angegebene Tabelle eingefügt. Die **Argument** -Spalte enthält auch ein SET:()-Prädikat, mit dem der Wert angegeben wird, auf den die einzelnen Spalten festgelegt sind. Wenn **Table Insert** keine untergeordneten Elemente für Eingabewerte enthält, wird die eingefügte Zeile aus dem Insert-Operator selbst übernommen. **Table Insert** ist ein physischer Operator.|  
|![Table Merge-Operator](../relational-databases/media/table-merge-32x.gif "Table Merge-Operator")|**Table Merge**|Der **Table Merge** -Operator wendet einen Mergedatenstrom auf einen Heap an. Der Operator löscht oder aktualisiert Zeilen in der Tabelle, die in der **Argument** -Spalte des Operators angegeben ist, bzw. fügt Zeilen in diese ein. Der tatsächlich ausgeführte Vorgang ist vom Laufzeitwert der in der **Argument** -Spalte des Operators angegebenen **ACTION** -Spalte abhängig. **Table Merge** ist ein physischer Operator.|  
|![Table Scan-Operator (Symbol)](../relational-databases/media/table-scan-32x.gif "Table Scan-Operator (Symbol)")|**Table Scan**|Mit dem Operator **Table Scan** werden alle Zeilen aus der in der **Argument** -Spalte angegebenen Tabelle des Abfrageausführungsplans abgerufen. Wenn ein WHERE:()-Prädikat in der **Argument** -Spalte angezeigt wird, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. **Table Scan** ist ein logischer und physischer Operator.|  
|![Table Spool-Operator (Symbol)](../relational-databases/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")|**Table Spool**|Der **Table Spool** -Operator scannt die Eingabe und platziert eine Kopie jeder Zeile in einer verborgenen Spooltabelle, die in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert und nur für die Dauer der Abfrage vorhanden ist. Wenn der Operator zurückgesetzt wird (beispielsweise aufgrund eines **Nested Loops** -Operators), aber keine erneute Zuordnung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. **Table Spool** ist ein physischer Operator.|  
|![Table Update-Operator (Symbol)](../relational-databases/media/table-update-32x.gif "Table Update-Operator (Symbol)")|**Table Update**|Mithilfe des physischen **Table Update** -Operators werden Eingabezeilen aktualisiert, die in der **Argument** -Spalte des Abfrageausführungsplans angegeben werden. Das SET:()-Prädikat bestimmt den Wert jeder aktualisierten Spalte. Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie an anderer Stelle dieser Abfrage verwiesen werden.|  
|![Tabellenwertfunktion-Operator (Symbol)](../relational-databases/media/table-valued-function-32x.gif "-Tabellenwertfunktion-Operator (Symbol)")|**Table-valued Function**|Mit dem Operator **Tabellenwertfunktion** wird eine Tabellenwertfunktion ausgewertet ( [!INCLUDE[tsql](../includes/tsql-md.md)] oder CLR), und die Ergebniszeilen werden in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert. Wenn die übergeordneten Iteratoren die Zeilen anfordern, gibt die **Tabellenwertfunktion** die Zeilen aus **tempdb**zurück.<br /><br /> Abfragen mit Aufrufen von Tabellenwertfunktionen generieren Abfragepläne mit dem **Tabellenwertfunktion** -Iterator. Die**Tabellenwertfunktion** kann mit verschiedenen Parameterwerten analysiert werden:<br /><br /> -<br />                    Der**Tabellenwertfunktion-XML-Leser** gibt einen XML-BLOB als Parameter ein und erstellt ein Rowset, das XML-Knoten in der XML-Dokumentreihenfolge darstellt. Andere Eingabeparameter können die zurückgegebenen XML-Knoten auf eine Teilmenge von XML-Dokumenten einschränken.<br /><br /> -**Tabellenwertfunktion-XML-Leser mit XPath-Filter** ist ein spezieller Typ von **Tabellenwertfunktion-XML-Leser** , der die Ausgabe auf XML-Knoten einschränkt, die einen XPath-Ausdruck erfüllen.<br /><br /> Die**Tabellenwertfunktion** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Top-Operator (Symbol)](../relational-databases/media/top-32x.gif "Top-Operator (Symbol)")|**Top**|Der **Top** -Operator scannt die Eingabe und gibt nur die angegebene Anzahl bzw. den angegebenen Prozentsatz von Zeilen zurück, meist basierend auf einer Sortierreihenfolge. Die **Argument** -Spalte kann eine Liste der Spalten enthalten, die auf Verbindungen überprüft werden. In Updateplänen wird der **Top** -Operator verwendet, um die Einschränkung der Zeilenanzahl zu erzwingen. **Top** ist sowohl ein logischer als auch physischer Operator. **Top** ist sowohl ein logischer als auch physischer Operator.|  
|Keine|**Top N Sort**|**Top N Sort** ähnelt dem **Sort** -Iterator. Es werden allerdings nur die ersten *N* benötigt, und nicht das gesamte Resultset. Bei kleinen Werten für *N*versucht das [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] -Abfrageausführungsmodul, den gesamten Sortiervorgang im Arbeitsspeicher auszuführen. Bei großen Werten für *N*greift das Abfrageausführungsmodul auf die mehr generische Methode der Sortierung zurück, für die *N* kein Parameter ist.|  
|![Erweiterter Operator (UDX – Symbol)](../relational-databases/media/udx-32x.gif "Erweiterter Operator (UDX – Symbol)")|**UDX**|Erweiterte Operatoren (UDX) implementieren einen von vielen XQuery- und XPath-Vorgängen in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Alle UDX-Operatoren sind sowohl logische als auch physische Operatoren.<br /><br /> Mit dem erweiterten Operator (UDX) **FOR XML** wird das relationale Rowset serialisiert, das in die XML-Darstellung einer einzelnen BLOB-Spalte in einer einzigen Ausgabezeile eingegeben wird. Bei diesem XML-Aggregationsoperator wird die Reihenfolge berücksichtigt.<br /><br /> Der erweiterte Operator (UDX) **XML SERIALIZER** ist ein XML-Aggregationsoperator, bei dem die Reihenfolge berücksichtigt wird. Er gibt Zeilen ein, die XML-Knoten oder XQuery-Skalarwerte in der XML-Dokumentreihenfolge darstellen, und erstellt eine serialisierte XML-BLOB-Spalte in einer einzelnen XML-Spalte in einer einzigen Ausgabezeile.<br /><br /> Der erweiterte Operator (UDX) **XML FRAGMENT SERIALIZER** ist eine Sonderform von **XML SERIALIZER** , womit Eingabezeilen verarbeitet werden, die XML-Fragmente darstellen, die in der XQuery-Erweiterung zum Ändern von Einfügungsdaten eingefügt werden.<br /><br /> Der erweiterte Operator (UDX) **XQUERY STRING** wertet den XQuery-Zeichenfolgenwert von Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der den Zeichenfolgenwert der Eingabe enthält.<br /><br /> Der erweiterte Operator (UDX) **XQUERY LIST DECOMPOSER** ist ein XQuery-Listendekompositionsoperator. Für jede Eingabezeile, die einen XML-Knoten darstellt, erstellt dieser Operator mindestens eine Zeile, die einen XQuery-Skalarwert mit einem Listenelementwert darstellt, falls die Eingabe vom XSD-Listentyp ist.<br /><br /> Der erweiterte Operator (UDX) **XQUERY DATA** wertet die XQuery-Funktion fn:data() in Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:data()**enthält.<br /><br /> Der erweiterte Operator **XQUERY CONTAINS** wertet die XQuery-Funktion fn:contains() in Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:contains()**enthält.<br /><br /> Der erweiterte Operator **UPDATE XML NODE** aktualisiert XML-Knoten in der XQuery-Erweiterung zum Ändern von Ersetzungsdaten in der **modify()** -Methode vom XML-Typ.|  
|Keine|**Union**|Der **Union** -Operator scannt mehrere Eingaben und gibt alle gescannten Zeilen aus, wobei Duplikate entfernt werden. **Union** ist ein logischer Operator.|  
|![Update (Datenbankmodul – Operatorsymbol)](../relational-databases/media/update-32x.gif "Update (Datenbankmodul – Operatorsymbol)")|**Update**|Mithilfe des **Update** -Operators wird jede Zeile mit der entsprechenden Eingabe in das Objekt aktualisiert, das in der **Argument** -Spalte des Abfrageausführungsplans angegeben ist. **Update** ist ein logischer Operator. Der physische Operator ist **Table Update**, **Index Update**oder **Clustered Index Update**.|  
|While-Sprachelement (Symbol)![While-Sprachelement (Symbol)](../relational-databases/media/while-32x.gif "While-Sprachelement (Symbol)")|**While**|Der **While** -Operator implementiert die WHILE-Schleife von [!INCLUDE[tsql](../includes/tsql-md.md)] . **While** ist ein Sprachelement.|  
|![Table Spool-Operator (Symbol)](../relational-databases/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")|**Window Spool**|Der **Window Spool** -Operator erweitert jede Zeile in den Satz von Zeilen, die das ihm zugeordnete Fenster darstellen. In einer Abfrage definiert die OVER-Klausel das Fenster innerhalb eines Abfrageresultsets, und eine Fensterfunktion berechnet dann einen Wert für jede Zeile im Fenster. **Window Spool** ist sowohl ein logischer als auch physischer Operator.|  
  
  
