---
title: CREATE TABLE (Transact-SQL) | Microsoft-Dokumentation
ms.custom: ''
ms.date: 08/10/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.service: ''
ms.component: t-sql|statements
ms.reviewer: ''
ms.suite: sql
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: language-reference
f1_keywords:
- FILESTREAM_TSQL
- TABLE
- CREATE_TABLE_TSQL
- CREATE TABLE
- FILESTREAM
- TABLE_TSQL
- FILESTREAM_ON
- FILESTREAM_ON_TSQL
dev_langs:
- TSQL
helpviewer_keywords:
- CHECK constraints
- global temporary tables [SQL Server]
- local temporary tables [SQL Server]
- size [SQL Server], tables
- UNIQUE constraints [SQL Server], creating
- constraints [SQL Server], columns
- maximum number of indexes per table
- number of tables per database
- number of indexes per table
- table creation [SQL Server], CREATE TABLE
- temporary tables [SQL Server], creating
- table size [SQL Server]
- nullability [SQL Server]
- partitioned tables [SQL Server], creating
- DEFAULT definition
- null values [SQL Server], columns
- number of rows per table
- maximum number of columns per table
- FOREIGN KEY constraints, creating
- PRIMARY KEY constraints
- number of bytes per row
- CREATE TABLE statement
- number of columns per table
- maximum number of bytes per row
ms.assetid: 1e068443-b9ea-486a-804f-ce7b6e048e8b
caps.latest.revision: 256
author: edmacauley
ms.author: edmaca
manager: craigg
ms.workload: Active
ms.openlocfilehash: 9f0a96fb3d9ffabc97ae32afbaa2462a34ec14e3
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/16/2018
---
# <a name="create-table-transact-sql"></a>CREATE TABLE (Transact-SQL)
[!INCLUDE[tsql-appliesto-ss2008-asdb-xxxx-xxx-md](../../includes/tsql-appliesto-ss2008-asdb-xxxx-xxx-md.md)]

  Erstellt eine neue Tabelle in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].  
  
[!INCLUDE[ssMIlimitation](../../includes/sql-db-mi-limitation.md)]

> [!NOTE]   
>  Eine [!INCLUDE[ssSDW](../../includes/sssdw-md.md)]-Syntax finden Sie unter [CREATE TABLE (Azure SQL Data Warehouse)](../../t-sql/statements/create-table-azure-sql-data-warehouse.md).
  
 ![Themenlinksymbol](../../database-engine/configure-windows/media/topic-link.gif "Topic link icon") [Transact-SQL Syntax Conventions (Transact-SQL-Syntaxkonventionen)](../../t-sql/language-elements/transact-sql-syntax-conventions-transact-sql.md)  
  
## <a name="simple-syntax"></a>Einfache Syntax  
  
```  
--Simple CREATE TABLE Syntax (common if not using options)  
CREATE TABLE   
    [ database_name . [ schema_name ] . | schema_name . ] table_name   
    ( { <column_definition> } [ ,...n ] )   
[ ; ]  
```  
  
## <a name="full-syntax"></a>Vollst√§ndige Syntax  
  
```  
--Disk-Based CREATE TABLE Syntax  
CREATE TABLE   
    [ database_name . [ schema_name ] . | schema_name . ] table_name   
    [ AS FileTable ]  
    ( {   <column_definition>   
        | <computed_column_definition>    
        | <column_set_definition>   
        | [ <table_constraint> ]   
        | [ <table_index> ] }  
          [ ,...n ]    
          [ PERIOD FOR SYSTEM_TIME ( system_start_time_column_name   
             , system_end_time_column_name ) ]  
      )  
    [ ON { partition_scheme_name ( partition_column_name )   
           | filegroup   
           | "default" } ]   
    [ TEXTIMAGE_ON { filegroup | "default" } ]   
    [ FILESTREAM_ON { partition_scheme_name   
           | filegroup   
           | "default" } ]  
    [ WITH ( <table_option> [ ,...n ] ) ]  
[ ; ]  
  
<column_definition> ::=  
column_name <data_type>  
    [ FILESTREAM ]  
    [ COLLATE collation_name ]   
    [ SPARSE ]  
    [ MASKED WITH ( FUNCTION = ' mask_function ') ]  
    [ CONSTRAINT constraint_name [ DEFAULT constant_expression ] ]   
    [ IDENTITY [ ( seed,increment ) ]  
    [ NOT FOR REPLICATION ]   
    [ GENERATED ALWAYS AS ROW { START | END } [ HIDDEN ] ]   
    [ NULL | NOT NULL ]  
    [ ROWGUIDCOL ]  
    [ ENCRYPTED WITH   
        ( COLUMN_ENCRYPTION_KEY = key_name ,  
          ENCRYPTION_TYPE = { DETERMINISTIC | RANDOMIZED } ,   
          ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256'  
        ) ]  
    [ <column_constraint> [ ...n ] ]   
    [ <column_index> ]  
  
<data type> ::=   
[ type_schema_name . ] type_name   
    [ ( precision [ , scale ] | max |   
        [ { CONTENT | DOCUMENT } ] xml_schema_collection ) ]   
  
<column_constraint> ::=   
[ CONSTRAINT constraint_name ]   
{     { PRIMARY KEY | UNIQUE }   
        [ CLUSTERED | NONCLUSTERED ]   
        [   
            WITH FILLFACTOR = fillfactor    
          | WITH ( < index_option > [ , ...n ] )   
        ]   
        [ ON { partition_scheme_name ( partition_column_name )   
            | filegroup | "default" } ]  
  
  | [ FOREIGN KEY ]   
        REFERENCES [ schema_name . ] referenced_table_name [ ( ref_column ) ]   
        [ ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ]   
        [ ON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ]   
        [ NOT FOR REPLICATION ]   
  
  | CHECK [ NOT FOR REPLICATION ] ( logical_expression )   
}   
  
<column_index> ::=   
 INDEX index_name [ CLUSTERED | NONCLUSTERED ]  
    [ WITH ( <index_option> [ ,... n ] ) ]  
    [ ON { partition_scheme_name (column_name )   
         | filegroup_name  
         | default   
         }  
    ]   
    [ FILESTREAM_ON { filestream_filegroup_name | partition_scheme_name | "NULL" } ]  
  
<computed_column_definition> ::=  
column_name AS computed_column_expression   
[ PERSISTED [ NOT NULL ] ]  
[   
    [ CONSTRAINT constraint_name ]  
    { PRIMARY KEY | UNIQUE }  
        [ CLUSTERED | NONCLUSTERED ]  
        [   
            WITH FILLFACTOR = fillfactor   
          | WITH ( <index_option> [ , ...n ] )  
        ]  
        [ ON { partition_scheme_name ( partition_column_name )   
        | filegroup | "default" } ]  
  
    | [ FOREIGN KEY ]   
        REFERENCES referenced_table_name [ ( ref_column ) ]   
        [ ON DELETE { NO ACTION | CASCADE } ]   
        [ ON UPDATE { NO ACTION } ]   
        [ NOT FOR REPLICATION ]   
  
    | CHECK [ NOT FOR REPLICATION ] ( logical_expression )   
]   
  
<column_set_definition> ::=  
column_set_name XML COLUMN_SET FOR ALL_SPARSE_COLUMNS  
  
< table_constraint > ::=  
[ CONSTRAINT constraint_name ]   
{   
    { PRIMARY KEY | UNIQUE }   
        [ CLUSTERED | NONCLUSTERED ]   
        (column [ ASC | DESC ] [ ,...n ] )   
        [   
            WITH FILLFACTOR = fillfactor   
           |WITH ( <index_option> [ , ...n ] )   
        ]  
        [ ON { partition_scheme_name (partition_column_name)  
            | filegroup | "default" } ]   
    | FOREIGN KEY   
        ( column [ ,...n ] )   
        REFERENCES referenced_table_name [ ( ref_column [ ,...n ] ) ]   
        [ ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ]   
        [ ON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ]   
        [ NOT FOR REPLICATION ]   
    | CHECK [ NOT FOR REPLICATION ] ( logical_expression )  
 

  
< table_index > ::=   
{  
    {  
      INDEX index_name [ CLUSTERED | NONCLUSTERED ]   
         (column_name [ ASC | DESC ] [ ,... n ] )   
    | INDEX index_name CLUSTERED COLUMNSTORE  
    | INDEX index_name [ NONCLUSTERED ] COLUMNSTORE (column_name [ ,... n ] )  
    }  
    [ WITH ( <index_option> [ ,... n ] ) ]   
    [ ON { partition_scheme_name (column_name )   
         | filegroup_name  
         | default   
         }  
    ]   
    [ FILESTREAM_ON { filestream_filegroup_name | partition_scheme_name | "NULL" } ]  
  
}   


<table_option> ::=  
{  
    [DATA_COMPRESSION = { NONE | ROW | PAGE }  
      [ ON PARTITIONS ( { <partition_number_expression> | <range> }   
      [ , ...n ] ) ]]  
    [ FILETABLE_DIRECTORY = <directory_name> ]   
    [ FILETABLE_COLLATE_FILENAME = { <collation_name> | database_default } ]  
    [ FILETABLE_PRIMARY_KEY_CONSTRAINT_NAME = <constraint_name> ]  
    [ FILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME = <constraint_name> ]  
    [ FILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME = <constraint_name> ]  
    [ SYSTEM_VERSIONING = ON [ ( HISTORY_TABLE = schema_name . history_table_name  
        [, DATA_CONSISTENCY_CHECK = { ON | OFF } ] ) ] ]  
    [ REMOTE_DATA_ARCHIVE =   
      {   
          ON [ ( <table_stretch_options> [,...n] ) ]  
        | OFF ( MIGRATION_STATE = PAUSED )   
      }   
    ]  
}  
  
<table_stretch_options> ::=  
{  
     [ FILTER_PREDICATE = { null | table_predicate_function } , ]  
       MIGRATION_STATE = { OUTBOUND | INBOUND | PAUSED }  
 }  
  
<index_option> ::=  
{   
    PAD_INDEX = { ON | OFF }   
  | FILLFACTOR = fillfactor   
  | IGNORE_DUP_KEY = { ON | OFF }   
  | STATISTICS_NORECOMPUTE = { ON | OFF }   
  | ALLOW_ROW_LOCKS = { ON | OFF}   
  | ALLOW_PAGE_LOCKS ={ ON | OFF}   
  | COMPRESSION_DELAY= {0 | delay [Minutes]}  
  | DATA_COMPRESSION = { NONE | ROW | PAGE | COLUMNSTORE | COLUMNSTORE_ARCHIVE }  
       [ ON PARTITIONS ( { <partition_number_expression> | <range> }   
       [ , ...n ] ) ]  
}  
<range> ::=   
<partition_number_expression> TO <partition_number_expression>  
```  
  
```  
  
      --Memory optimized CREATE TABLE Syntax  
CREATE TABLE  
    [database_name . [schema_name ] . | schema_name . ] table_name  
    ( { <column_definition>  
    | [ <table_constraint> ] [ ,... n ]  
    | [ <table_index> ]  
      [ ,... n ] }   
      [ PERIOD FOR SYSTEM_TIME ( system_start_time_column_name   
        , system_end_time_column_name ) ]  
)  
    [ WITH ( <table_option> [ ,... n ] ) ]  
 [ ; ]  
  
<column_definition> ::=  
column_name <data_type>  
    [ COLLATE collation_name ]  
    [ GENERATED ALWAYS AS ROW { START | END } [ HIDDEN ] ]   
    [ NULL | NOT NULL ]  
[  
    [ CONSTRAINT constraint_name ] DEFAULT memory_optimized_constant_expression ]  
    | [ IDENTITY [ ( 1, 1 ) ]  
]  
    [ <column_constraint> ]  
    [ <column_index> ]  
  
<data type> ::=  
 [type_schema_name . ] type_name [ (precision [ , scale ]) ]  
  
<column_constraint> ::=  
 [ CONSTRAINT constraint_name ]  
{   
  { PRIMARY KEY | UNIQUE }    
      {   NONCLUSTERED   
        | NONCLUSTERED HASH WITH (BUCKET_COUNT = bucket_count)   
      }   
  | [ FOREIGN KEY ]   
        REFERENCES [ schema_name . ] referenced_table_name [ ( ref_column ) ]   
  | CHECK ( logical_expression )   
}  
  
< table_constraint > ::=  
 [ CONSTRAINT constraint_name ]  
{    
   { PRIMARY KEY | UNIQUE }  
     {   
       NONCLUSTERED (column [ ASC | DESC ] [ ,... n ])  
       | NONCLUSTERED HASH (column [ ,... n ] ) WITH ( BUCKET_COUNT = bucket_count )   
                    }   
    | FOREIGN KEY   
        ( column [ ,...n ] )   
        REFERENCES referenced_table_name [ ( ref_column [ ,...n ] ) ]   
    | CHECK ( logical_expression )   
}  
  
<column_index> ::=  
  INDEX index_name  
{ [ NONCLUSTERED ] | [ NONCLUSTERED ] HASH WITH (BUCKET_COUNT = bucket_count)  }  
  
<table_index> ::=  
  INDEX index_name  
{   [ NONCLUSTERED ] HASH (column [ ,... n ] ) WITH (BUCKET_COUNT = bucket_count)   
  | [ NONCLUSTERED ] (column [ ASC | DESC ] [ ,... n ] )   
      [ ON filegroup_name | default ]  
  | CLUSTERED COLUMNSTORE [WITH ( COMPRESSION_DELAY = {0 | delay [Minutes]})]  
      [ ON filegroup_name | default ]  
  
}  
  
<table_option> ::=  
{  
    MEMORY_OPTIMIZED = ON   
  | DURABILITY = {SCHEMA_ONLY | SCHEMA_AND_DATA}  
  | SYSTEM_VERSIONING = ON [ ( HISTORY_TABLE = schema_name . history_table_name  
        [, DATA_CONSISTENCY_CHECK = { ON | OFF } ] ) ]   
  
}  
```  
  
## <a name="arguments"></a>Argumente  
 *database_name*  
 Der Name der Datenbank, in der die Tabelle erstellt wird. *database_name* muss dem Namen einer vorhandenen Datenbank entsprechen. Wird *database_name* nicht angegeben, wird standardm√§√üig die aktuelle Datenbank verwendet. Der Anmeldename f√ºr die aktuelle Verbindung muss einer vorhandenen Benutzer-ID in der durch *database_name* angegebenen Datenbank zugeordnet sein. Diese Benutzer-ID muss √ºber CREATE TABLE-Berechtigungen verf√ºgen.  
  
 *schema_name*  
 Der Name des Schemas, zu dem die neue Tabelle geh√∂rt.  
  
 *table_name*  
 Der Name der neuen Tabelle. Tabellennamen m√ºssen die Regeln f√ºr [Bezeichner](../../relational-databases/databases/database-identifiers.md) erf√ºllen. *table_name* kann h√∂chstens 128 Zeichen aufweisen, ausgenommen lokale tempor√§re Tabellennamen (Namen mit einem Nummernzeichen (#) als Pr√§fix), bei denen maximal 116 Zeichen zul√§ssig sind.  
  
 AS FileTable 
 
**Gilt f√ºr**: [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
 
 Erstellt die neue Tabelle als FileTable. Sie geben keine Spalten an, da eine FileTable √ºber ein festes Schema verf√ºgt. Weitere Informationen zu FileTables finden Sie unter [FileTables &#40;SQL Server&#41;](../../relational-databases/blob/filetables-sql-server.md).  
  
 *column_name*  
 *computed_column_expression*  
 Ein Ausdruck, der den Wert einer berechneten Spalte definiert. Eine berechnete Spalte ist eine virtuelle Spalte, die nicht physisch in der Tabelle gespeichert ist, es sei denn, die Spalte wurde (mit PERSISTED) als persistente Spalte markiert. Die Spalte wird anhand eines Ausdrucks berechnet, der andere Spalten in derselben Tabelle verwendet. Eine berechnete Spalte kann beispielsweise folgende Definition aufweisen: **cost** AS **price**\***qty**. Der Ausdruck kann der Name einer nicht berechneten Spalte, eine Konstante, eine Funktion, eine Variable oder eine beliebige durch einen oder mehrere Operatoren verbundene Kombination der genannten M√∂glichkeiten sein. Der Ausdruck darf keine Unterabfrage sein oder Aliasdatentypen enthalten.  
  
 Berechnete Spalten k√∂nnen in SELECT-Listen, WHERE-Klauseln, ORDER BY-Klauseln oder an anderen Stellen verwendet werden, an denen regul√§re Ausdr√ºcke verwendet werden k√∂nnen. Dabei gelten folgende Ausnahmen:  
  
-   Berechnete Spalten m√ºssen als PERSISTED gekennzeichnet sein, um Teil einer FOREIGN KEY- oder CHECK-Einschr√§nkung zu sein.  
  
-   Eine berechnete Spalte kann als Schl√ºsselspalte in einem Index oder als Teil einer PRIMARY KEY- oder UNIQUE-Einschr√§nkung verwendet werden, wenn der Wert der berechneten Spalte durch einen deterministischen Ausdruck definiert ist und der Datentyp des Ergebnisses in Indexspalten zul√§ssig ist.  
  
     Wenn eine Tabelle beispielsweise die beiden ganzzahligen Spalten **a** und **b** enth√§lt, kann f√ºr die berechnete Spalte **a+b** ein Index erstellt werden. F√ºr die berechnete Spalte **a+DATEPART(dd, GETDATE())** ist dies jedoch nicht m√∂glich, da sich der Wert in sp√§teren Aufrufen m√∂glicherweise √§ndert.  
  
-   Eine berechnete Spalte kann nicht das Ziel einer INSERT- oder UPDATE-Anweisung sein.  
  
> [!NOTE]  
>  Jede Zeile in einer Tabelle kann unterschiedliche Werte in den Spalten aufweisen, die f√ºr eine berechnete Spalte herangezogen werden, daher enth√§lt die berechnete Spalte m√∂glicherweise nicht in jeder Zeile den gleichen Wert.  
  
 Die NULL-Zul√§ssigkeit berechneter Spalten wird automatisch von [!INCLUDE[ssDE](../../includes/ssde-md.md)] auf Grundlage der verwendeten Ausdr√ºcke bestimmt. F√ºr das Ergebnis der meisten Ausdr√ºcke wird die NULL-Zul√§ssigkeit angenommen, und zwar auch dann, wenn nur Spalten vorhanden sind, die keine NULL-Werte zulassen, da m√∂gliche Unter- oder √úberl√§ufe ebenfalls zu NULL-Ergebnissen f√ºhren. Verwenden Sie die COLUMNPROPERTY-Funktion mit der Eigenschaft **AllowsNull**, um die NULL-Zul√§ssigkeit von berechneten Spalten in einer Tabelle zu untersuchen. Ein Ausdruck, der NULL-Werte zul√§sst, kann nur durch die Angabe von ISNULL mit der Konstante in einen Ausdruck umgewandelt werden, der keine NULL-Werte zul√§sst. Die Konstante *check_expression* ist ein Wert ungleich NULL, durch den jedes NULL-Ergebnis ersetzt wird. F√ºr berechnete Spalten, die auf CLR-benutzerdefinierten Typausdr√ºcken (Common Language Runtime) basieren, ist die REFERENCES-Berechtigung f√ºr den Typ erforderlich.  
  
 PERSISTED  
 Gibt an, dass das [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] die berechneten Werte physisch in der Tabelle speichert und die Werte aktualisiert, wenn Spalten, von denen die berechnete Spalte abh√§ngt, aktualisiert werden. Wenn Sie eine berechnete Spalte (mit PERSISTED) als persistente Spalte markieren, k√∂nnen Sie einen Index f√ºr eine berechnete Spalte erstellen, die deterministisch, jedoch nicht genau ist. Weitere Informationen finden Sie unter [Indexes on Computed Columns](../../relational-databases/indexes/indexes-on-computed-columns.md). Alle berechneten Spalten, die als Partitionierungsspalten einer partitionierten Tabelle verwendet werden, m√ºssen ausdr√ºcklich als PERSISTED gekennzeichnet sein. *computed_column_expression* muss deterministisch sein, wenn PERSISTED angegeben wird.  
  
 ON { *partition_scheme* | *filegroup* | **"** default **"** }  

 Gibt das Partitionsschema oder die Dateigruppe an, in der die Tabelle gespeichert wird. Wenn *partition_scheme* angegeben wird, soll die Tabelle eine partitionierte Tabelle sein, deren Partitionen in einem Satz aus einer oder mehreren in *partition_scheme* angegebenen Dateigruppen gespeichert werden. Wenn *filegroup* angegeben ist, wird die Tabelle in der genannten Dateigruppe gespeichert. Die Dateigruppe muss in der Datenbank vorhanden sein. Wenn **"** default **"** angegeben oder ON nicht angegeben sind, wird die Tabelle in der Standarddateigruppe gespeichert. Der in CREATE TABLE angegebene Speichermechanismus einer Tabelle kann nachfolgend nicht mehr ge√§ndert werden.  
  
 ON {*partition_scheme* | *filegroup* | **"** default **"**} kann auch in den Einschr√§nkungen PRIMARY KEY oder UNIQUE angegeben werden. Diese Einschr√§nkungen erstellen Indizes. Wenn *filegroup* angegeben ist, wird der Index in der genannten Dateigruppe gespeichert. Wenn **"** default **"** angegeben oder ON √ºberhaupt nicht angegeben sind, wird der Index in derselben Dateigruppe wie die Tabelle gespeichert. Wenn die PRIMARY KEY- oder die UNIQUE-Einschr√§nkung einen gruppierten Index erstellt, werden die Datenseiten f√ºr die Tabelle in derselben Dateigruppe wie der Index gespeichert. Wenn CLUSTERED angegeben wird oder ein gruppierter Index anderweitig durch die Einschr√§nkung erstellt wird, und ein Wert f√ºr *partition_scheme* angegeben wird, der von der Angabe f√ºr *partition_scheme* oder *filegroup* der Tabellendefinition abweicht (oder umgekehrt), wird nur die Einschr√§nkungsdefinition ber√ºcksichtigt. Der andere Wert wird ignoriert.  
  
> [!NOTE]  
>  In diesem Zusammenhang ist DEFAULT kein Schl√ºsselwort. Es handelt sich dabei um einen Bezeichner f√ºr die Standarddateigruppe. Dieser muss wie in ON **"** default **"** or ON **[** default **]** durch Trennzeichen getrennt werden. Wenn **"** default **"** angegeben ist, muss die QUOTED_IDENTIFIER-Option in der aktuellen Sitzung auf ON festgelegt sein. Dies ist die Standardeinstellung. Weitere Informationen finden Sie unter [SET QUOTED_IDENTIFIER &#40;Transact-SQL&#41;](../../t-sql/statements/set-quoted-identifier-transact-sql.md).  
  
> [!NOTE]  
>  Nachdem Sie eine partitionierte Tabelle erstellt haben, erw√§gen Sie, die LOCK_ESCALATION-Option f√ºr die Tabelle auf AUTO festzulegen. Dies kann die Parallelit√§t verbessern, indem die Sperren auf Partitionsebene (HoBT) statt auf Tabellenebene aktiviert werden. Weitere Informationen finden Sie unter [ALTER TABLE &#40;Transact-SQL&#41;](../../t-sql/statements/alter-table-transact-sql.md).  
  
 TEXTIMAGE_ON { *filegroup*| **"** default **"** }  
 Gibt an, dass die Spalten vom Typ **text**, **ntext**, **image**, **xml**, **varchar(max)**, **nvarchar(max)**, **varbinary(max)** und eines CLR-benutzerdefinierten Typs (einschlie√ülich ‚Äûgeometry‚Äú und ‚Äûgeography‚Äú) in der angegebenen Dateigruppe gespeichert werden.  
  
 TEXTIMAGE_ON ist nicht zul√§ssig, wenn die Tabelle keine Spalten f√ºr umfangreiche Werte enth√§lt. TEXTIMAGE_ON darf nicht angegeben werden, wenn *partition_scheme* angegeben wird. Wenn **"** default **"** angegeben wird oder TEXTIMAGE_ON nicht angegeben wird, werden die Spalten f√ºr umfangreiche Werte in der Standarddateigruppe gespeichert. Die in CREATE TABLE angegebene Speicherung einer Spalte f√ºr umfangreiche Werte kann nachfolgend nicht mehr ge√§ndert werden.  

> [!NOTE]  
> Varchar(max), nvarchar(max), varbinary(max), XML und gro√üe UDT-Werte werden bis zu einem H√∂chstwert von 8000 Bytes direkt in der Datenzeile gespeichert, sofern der Wert die Gr√∂√üe des Datensatzes nicht √ºberschreitet. √úberschreitet der Wert die Gr√∂√üe des Datensatzes, wird ein Zeiger innerhalb der Zeilen gespeichert, w√§hrend der Rest au√üerhalb der Zeilen im LOB-Speicherbereich gespeichert wird. Der Standardwert ist 0 (null).
TEXTIMAGE_ON √§ndert nur den Speicherort des LOB-Speicherbereichs ‚Äì in Zeilen gespeicherte Daten werden nicht beeintr√§chtigt. Verwenden Sie gro√üe Werttypen von ‚Äûsp_tableoption‚Äú au√üerhalb der Zeilen, um den gesamten LOB-Wert au√üerhalb der Zeile zu speichern. 


> [!NOTE]  
>  In diesem Zusammenhang ist DEFAULT kein Schl√ºsselwort. Es handelt sich um einen Bezeichner f√ºr die Standarddateigruppe, der begrenzt werden muss, wie z.B. in TEXTIMAGE_ON **"** default **"** oder TEXTIMAGE_ON **[** default **]**. Wenn **"** default **"** angegeben ist, muss die QUOTED_IDENTIFIER-Option in der aktuellen Sitzung auf ON festgelegt sein. Dies ist die Standardeinstellung. Weitere Informationen finden Sie unter [SET QUOTED_IDENTIFIER &#40;Transact-SQL&#41;](../../t-sql/statements/set-quoted-identifier-transact-sql.md).  
  
 FILESTREAM_ON { *partition_scheme_name* | filegroup | **"** default **"** } **Gilt f√ºr**: [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]. 
 
 Gibt die Dateigruppe f√ºr FILESTREAM-Daten an.  
  
 Wenn die Tabelle FILESTREAM-Daten enth√§lt und partitioniert ist, muss die FILESTREAM_ON-Klausel eingeschlossen werden und ein Partitionsschema von FILESTREAM-Dateigruppen angeben. Dieses Partitionsschema muss die gleiche Partitionsfunktion und die gleichen Partitionsspalten wie das Partitionsschema der Tabelle verwenden. Andernfalls wird ein Fehler ausgel√∂st.  
  
 Wenn die Tabelle nicht partitioniert ist, kann die FILESTREAM-Spalte nicht partitioniert werden. Die FILESTREAM-Daten f√ºr die Tabelle m√ºssen in einer einzigen Dateigruppe gespeichert werden. Diese Dateigruppe wird in der FILESTREAM_ON-Klausel angegeben.  
  
 Wenn die Tabelle nicht partitioniert und die FILESTREAM_ON-Klausel nicht angegeben ist, wird die FILESTREAM-Dateigruppe mit dem DEFAULT-Eigenschaftensatz verwendet. Wenn keine FILESTREAM-Dateigruppe vorhanden ist, wird ein Fehler ausgel√∂st.  
  
-   Wie auch bei ON und TEXTIMAGE_ON kann der mit CREATE TABLE f√ºr FILESTREAM_ON festgelegte Wert nur in den folgenden F√§llen ge√§ndert werden:  
  
-   Eine [CREATE INDEX](../../t-sql/statements/create-index-transact-sql.md)-Anweisung konvertiert einen Heap in einen gruppierten Index. In diesem Fall kann eine andere FILESTREAM-Dateigruppe, ein anderes Partitionsschema oder NULL angegeben werden.  
  
-   Eine [DROP INDEX](../../t-sql/statements/drop-index-transact-sql.md)-Anweisung konvertiert einen gruppierten Index in einen Heap. In diesem Fall k√∂nnen eine andere FILESTREAM-Dateigruppe, ein anderes Partitionsschema oder **"** default **"** angegeben werden.  
  
 F√ºr die Dateigruppe in der Klausel `FILESTREAM_ON <filegroup>` bzw. f√ºr die einzelnen FILESTREAM-Dateigruppen im Partitionsschema muss jeweils eine Datei definiert sein. Diese Datei muss mit einer [CREATE DATABASE](../../t-sql/statements/create-database-sql-server-transact-sql.md)- oder [ALTER DATABASE](../../t-sql/statements/alter-database-transact-sql.md)-Anweisung definiert werden, andernfalls wird ein Fehler ausgel√∂st.  
  
 Verwandte Themen zu FILESTREAM finden Sie unter [Binary Large Object &#40;Blob&#41;-Daten &#40;SQL Server&#41;](../../relational-databases/blob/binary-large-object-blob-data-sql-server.md).  
  
 [ *type_schema_name***.** ] *type_name*  
 Gibt den Datentyp der Spalte sowie das Schema an, zu dem er geh√∂rt. F√ºr datentr√§gerbasierte Tabellen kann der Datentyp einer der folgenden sein:  
  
-   Systemdatentyp  
  
-   Ein Aliastyp, der auf einem [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Systemdatentyp basiert. Aliasdatentypen werden mit der CREATE TYPE-Anweisung erstellt, bevor sie in einer Tabellendefinition verwendet werden k√∂nnen. Die NULL- oder NOT NULL-Zuweisung f√ºr einen Aliasdatentyp l√§sst sich durch die entsprechende Angabe in einer CREATE TABLE-Anweisung √ºberschreiben. Die L√§ngenangabe kann jedoch nicht ge√§ndert werden; die L√§nge eines Aliasdatentyps kann nicht in einer CREATE TABLE-Anweisung angegeben werden.  
  
-   Ein CLR-benutzerdefinierter Typ. CLR-benutzerdefinierte Typen werden mit der CREATE TYPE-Anweisung erstellt, bevor sie in einer Tabellendefinition verwendet werden k√∂nnen. Zum Erstellen einer Spalte, die auf einem CLR-benutzerdefinierten Typ basiert, ist die REFERENCES-Berechtigung f√ºr den Typ erforderlich.  
  
 Wenn *type_schema_name* nicht angegeben ist, verweist [!INCLUDE[ssDEnoversion](../../includes/ssdenoversion-md.md)] auf *type_name* in der folgenden Reihenfolge:  
  
-   [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Systemdatentyp.  
  
-   Das Standardschema des aktuellen Benutzers in der aktuellen Datenbank  
  
-   Das **dbo** -Schema in der aktuellen Datenbank  
  
 Eine Liste unterst√ºtzter Systemtypen f√ºr speicheroptimierte Tabellen finden Sie unter [Unterst√ºtzte Datentypen f√ºr In-Memory OLTP](../../relational-databases/in-memory-oltp/supported-data-types-for-in-memory-oltp.md).  
  
 *precision*  
 Die Genauigkeit f√ºr den angegebenen Datentyp. Weitere Informationen √ºber g√ºltige Genauigkeitswerte finden Sie unter [Genauigkeit, Dezimalstellen und L√§nge](../../t-sql/data-types/precision-scale-and-length-transact-sql.md).  
  
 *scale*  
 Die Dezimalstellen f√ºr den angegebenen Datentyp. Weitere Informationen zu g√ºltigen Dezimalstellenwerten finden Sie unter [Genauigkeit, Dezimalstellen und L√§nge](../../t-sql/data-types/precision-scale-and-length-transact-sql.md).  
  
 **max**  
 Gilt nur f√ºr die Datentypen **varchar**, **nvarchar** und **varbinary** zum Speichern von 2^31 Byte an Zeichen- und Bin√§rdaten sowie von 2^30 Byte an Unicode-Daten.  
  
 CONTENT  
 Gibt an, dass jede Instanz des **XML**-Datentyps in *column_name* mehrere allgemeine Elemente enthalten kann. CONTENT gilt nur f√ºr den **xml**-Datentyp und kann nur angegeben werden, wenn *xml_schema_collection* ebenfalls angegeben ist. Wird der Parameter nicht angegeben, entspricht CONTENT dem Standardverhalten.  
  
 DOCUMENT  
 Gibt an, dass jede Instanz des **XML**-Datentyps in *column_name* nur ein allgemeines Element enthalten kann. DOCUMENT gilt nur f√ºr den **XML**-Datentyp und kann angegeben werden, wenn *xml_schema_collection* ebenfalls angegeben ist.  
  
 *xml_schema_collection*  
 Gilt nur f√ºr den **xml**-Datentyp zum Verkn√ºpfen einer XML-Schemaauflistung mit diesem Typ. Vor der Typisierung einer **xml**-Spalte mit einem Schema muss das Schema zuerst mithilfe von [CREATE XML SCHEMA COLLECTION](../../t-sql/statements/create-xml-schema-collection-transact-sql.md) in der Datenbank erstellt werden.  
  
 DEFAULT  
 Gibt den Wert an, der f√ºr die Spalte bereitgestellt wird, wenn kein Wert explizit angegeben wurde. DEFAULT-Definitionen k√∂nnen auf alle Spalten angewendet werden, mit Ausnahme der als **timestamp** definierten Spalten sowie von Spalten mit der IDENTITY-Eigenschaft. Wenn ein Standardwert f√ºr einen benutzerdefinierten Spaltentyp angegeben wird, sollte dieser Typ eine implizite Konvertierung von *constant_expression* in den benutzerdefinierten Typ unterst√ºtzen. DEFAULT-Definitionen werden entfernt, wenn die Tabelle gel√∂scht wird. Es kann nur ein konstanter Wert (z. B. eine Zeichenfolge), eine Skalarfunktion (entweder eine System-, eine benutzerdefinierte oder eine CLR-Funktion) oder NULL als Standardwert verwendet werden. Um die Kompatibilit√§t mit fr√ºheren Versionen von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] aufrechtzuerhalten, ist es m√∂glich, einer DEFAULT-Definition einen Einschr√§nkungsnamen zuzuweisen.  
  
 *constant_expression*  
 Eine Konstante, ein NULL-Wert oder eine Systemfunktion, die bzw. der als Standardwert f√ºr die Spalte verwendet wird.  
  
 *memory_optimized_constant_expression*  
 Eine Konstante, ein NULL-Wert oder eine Systemfunktion, die bzw. der als Standardwert f√ºr die Spalte verwendet wird. Muss in systemintern kompilierten gespeicherten Prozeduren unterst√ºtzt werden. Weitere Informationen zu den integrierten Features in nativ kompilierten gespeicherten Prozeduren finden Sie unter [Unterst√ºtzte Features f√ºr nativ kompilierte T-SQL-Module](../../relational-databases/in-memory-oltp/supported-features-for-natively-compiled-t-sql-modules.md).  
  
 IDENTITY  
 Gibt an, dass es sich bei der neuen Spalte um eine Identit√§tsspalte handelt. Wenn eine neue Zeile zur Tabelle hinzugef√ºgt wird, stellt [!INCLUDE[ssDE](../../includes/ssde-md.md)] einen eindeutigen, inkrementellen Wert f√ºr die Spalte bereit. Identit√§tsspalten werden √ºblicherweise zusammen mit PRIMARY KEY-Einschr√§nkungen verwendet, um als eindeutiger Zeilenbezeichner f√ºr die Tabelle zu dienen. Die IDENTITY-Eigenschaft kann folgenden Spalten zugewiesen werden: **tinyint**, **smallint**, **int**, **bigint**, **decimal(p,0)** oder **numeric(p,0)**. Es kann nur eine Identit√§tsspalte pro Tabelle erstellt werden. Gebundene Standardwerte und DEFAULT-Einschr√§nkungen k√∂nnen nicht mit einer Identit√§tsspalte verwendet werden. Entweder m√ºssen sowohl Ausgangswert als auch Schrittweite oder keines von beiden angegeben werden. Wurden Ausgangswert und inkrementeller Wert nicht angegeben, ist der Standardwert (1,1).  
  
 In einer speicheroptimierten Tabelle lautet der einzig zul√§ssige Wert sowohl f√ºr *seed* als auch f√ºr *increment* 1. (1,1) ist der Standardwert f√ºr *seed* und *increment*.  
  
 *seed*  
 Der Wert, der f√ºr die erste in die Tabelle geladene Zeile verwendet wird.  
  
 *increment*  
 Der Inkrementwert, der zum Identit√§tswert der zuvor geladenen Zeile addiert wird.  
  
 NOT FOR REPLICATION  
 In der CREATE TABLE-Anweisung kann die NOT FOR REPLICATION-Klausel f√ºr die IDENTITY-Eigenschaft, f√ºr FOREIGN KEY-Einschr√§nkungen und f√ºr CHECK-Einschr√§nkungen angegeben werden. Wenn diese Klausel f√ºr die IDENTITY-Eigenschaft angegeben wird, werden Werte in Identit√§tsspalten nicht inkrementiert, wenn Replikations-Agents Einf√ºgevorg√§nge ausf√ºhren. Wenn diese Klausel f√ºr eine Einschr√§nkung angegeben wird, wird die Einschr√§nkung nicht erzwungen, wenn Replikations-Agents Einf√ºge-, Update- oder L√∂schvorg√§nge ausf√ºhren.  
  
 GENERATED ALWAYS AS ROW { START | END } [ HIDDEN ] [ NOT NULL ]  
 **Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].  
  
 Gibt an, dass eine angegebene datetime2-Spalte vom System verwendet wird, um entweder die Startzeit oder die Endzeit aufzuzeichnen, f√ºr die ein Datensatz g√ºltig ist. Die Spalte muss als NOT NULL definiert werden. Das System l√∂st einen Fehler aus, wenn Sie versuchen, NULL anzugeben. Wenn Sie NOT NULL nicht explizit f√ºr eine Zeitraumspalte angeben, definiert das System die Spalte standardm√§√üig als NOT NULL. Verwenden Sie dieses Argument zusammen mit den Argumenten PERIOD FOR SYSTEM_TIME und WITH SYSTEM_VERSIONING = ON, um die Versionsverwaltung durch das System f√ºr eine Tabelle zu aktivieren. Weitere Informationen finden Sie unter [Temporal Tables](../../relational-databases/tables/temporal-tables.md).  
  
 Sie k√∂nnen eine oder beide Zeitraumspalten mit dem Flag **HIDDEN** kennzeichnen, um diese Spalten implizit auszublenden, sodass **SELECT \* FROM***`<table>`* f√ºr diese Spalten keinen Wert zur√ºckgibt. Standardm√§√üig sind Zeitraumspalten nicht ausgeblendet. Damit sie verwendet werden k√∂nnen, m√ºssen ausgeblendete Spalten explizit in allen Abfragen eingeschlossen werden, die direkt auf die temporale Tabelle verweisen. Zum √Ñndern des Attributs **HIDDEN** einer vorhandenen Zeitraumspalte, muss **PERIOD** gel√∂scht und mit einem anderen Flag neu erstellt werden.  
  
 `INDEX *index_name* [ CLUSTERED | NONCLUSTERED ] (*column_name* [ ASC | DESC ] [ ,... *n* ] )`  
     
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].

Gibt an, dass ein Index in der Tabelle erstellt werden soll. Dies kann ein gruppierter oder ein nicht gruppierter Index sein. Der Index enth√§lt die aufgelisteten Spalten und sortiert die Daten in aufsteigender oder absteigender Reihenfolge.  
  
 INDEX *index_name* CLUSTERED COLUMNSTORE  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 Gibt an, dass die gesamte Tabelle im Spaltenformat mit einem Columnstore-Index gespeichert werden soll. Dies beinhaltet immer alle Spalten in der Tabelle. Die Daten werden nicht in alphabetischer oder numerischer Reihenfolge sortiert, da die Zeilen zugunsten der Vorteile der Columnstore-Komprimierung organisiert sind.  
  
 INDEX *index_name* [ NONCLUSTERED ] COLUMNSTORE (*column_name* [ ,... *n* ] )  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 Gibt an, dass ein nicht gruppierter Columnstore-Index in der Tabelle erstellt werden soll. Die zugrunde liegende Tabelle kann ein Rowstore-Heap, gruppierter Index oder gruppierter Columnstore-Index sein. Eine zweite Kopie der Daten f√ºr die Spalten im Index wird immer gespeichert, wenn ein nicht gruppierter Columnstore-Index erstellt wird.  
  
 Der nicht gruppierte Columnstore-Index wird als gruppierter Columnstore-Index gespeichert und verwaltet. Er wird ‚Äûnicht gruppierter Columnstore-Index‚Äú genannt, da er als sekund√§rer Index in einer Tabelle fungiert und seine Spalten begrenzt sein k√∂nnen.  
  
 ON *partition_scheme_name ***(*** column_name***)**  
 Gibt das Partitionsschema an, das die Dateigruppen definiert, denen die Partitionen eines partitionierten Index zugeordnet werden. Das Partitionsschema muss bereits durch Ausf√ºhren von [CREATE PARTITION SCHEME](../../t-sql/statements/create-partition-scheme-transact-sql.md) oder [ALTER PARTITION SCHEME](../../t-sql/statements/alter-partition-scheme-transact-sql.md) in der Datenbank vorhanden sein. *column_name* gibt die Spalte an, auf deren Grundlage ein partitionierter Index partitioniert wird. Diese Spalte muss mit dem Datentyp, der L√§nge und der Genauigkeit des Arguments der Partitionsfunktion √ºbereinstimmen, die *partition_scheme_name* verwendet. *column_name* ist nicht auf Spalten in der Indexdefinition beschr√§nkt. Es k√∂nnen beliebige Spalten der Basistabelle angegeben werden, mit der Ausnahme, dass *column_name* beim Partitionieren von UNIQUE-Indizes aus den Spalten ausgew√§hlt werden muss, die als eindeutige Schl√ºssel verwendet werden. Mit dieser Einschr√§nkung kann [!INCLUDE[ssDE](../../includes/ssde-md.md)] die Eindeutigkeit der Schl√ºsselwerte in nur einer einzigen Partition √ºberpr√ºfen.  
  
> [!NOTE]  
>  Beim Partitionieren eines nicht eindeutigen gruppierten Index f√ºgt [!INCLUDE[ssDE](../../includes/ssde-md.md)] standardm√§√üig die Partitionierungsspalte zu der Liste der gruppierten Indexschl√ºssel hinzu, sofern sie dort noch nicht angegeben wurde. Beim Partitionieren eines nicht eindeutigen, nicht gruppierten Indexes f√ºgt [!INCLUDE[ssDE](../../includes/ssde-md.md)] die Partitionierungsspalte als (eingeschlossene) Nichtschl√ºsselspalte des Indexes hinzu, sofern sie noch nicht angegeben wurde.  
  
 Wenn *partition_scheme_name* oder *filegroup* bei einer partitionierten Tabelle nicht angegeben werden, wird der Index in demselben Partitionsschema platziert und verwendet dieselbe Partitionierungsspalte wie die zugrunde liegende Tabelle.  
  
> [!NOTE]  
>  Sie k√∂nnen kein Partitionierungsschema f√ºr einen XML-Index angeben. Beim Partitionieren der Basistabelle verwendet der XML-Index dasselbe Partitionsschema wie die Tabelle.  
  
 Weitere Informationen zur Partitionierung von Indizes finden Sie unter [Partitionierte Tabellen und Indizes](../../relational-databases/partitions/partitioned-tables-and-indexes.md).  
  
 ON *filegroup_name*  
 Erstellt den angegebenen Index f√ºr die angegebene Dateigruppe. Wenn kein Speicherort angegeben und die Tabelle oder Sicht nicht partitioniert ist, verwendet der Index dieselbe Dateigruppe wie die zugrunde liegende Tabelle oder Sicht. Die Dateigruppe muss bereits vorhanden sein.  
  
 ON **"** default **"**  
 Erstellt den angegebenen Index f√ºr die Standarddateigruppe.  
  
 Die Benennung default ist in diesem Kontext kein Schl√ºsselwort. Es handelt sich dabei um einen Bezeichner f√ºr die Standarddateigruppe. Dieser muss wie in ON **"** default **"** or ON **[** default **]** durch Trennzeichen getrennt werden. Wenn "default" angegeben wird, muss die Option QUOTED_IDENTIFIER f√ºr die aktuelle Sitzung auf ON festgelegt sein. Dies ist die Standardeinstellung. Weitere Informationen finden Sie unter [SET QUOTED_IDENTIFIER &#40;Transact-SQL&#41;](../../t-sql/statements/set-quoted-identifier-transact-sql.md).  
  
 [ FILESTREAM_ON { *filestream_filegroup_name* | *partition_scheme_name* | "NULL" } ]  
   
**Gilt f√ºr**: [!INCLUDE[ssNoVersion](../../includes/ssnoversion.md)].

 Gibt die Platzierung der FILESTREAM-Daten f√ºr die Tabelle an, wenn ein gruppierter Index erstellt wird. Die FILESTREAM_ON-Klausel l√§sst zu, dass FILESTREAM-Daten in eine andere FILESTREAM-Dateigruppe oder ein anderes Partitionsschema verschoben werden.  
  
 *filestream_filegroup_name* ist der Name einer FILESTREAM-Dateigruppe. F√ºr die Dateigruppe muss eine Datei mit einer [CREATE DATABASE](../../t-sql/statements/create-database-sql-server-transact-sql.md)-Anweisung oder einer [ALTER DATABASE](../../t-sql/statements/alter-database-transact-sql.md)-Anweisung definiert worden sein, andernfalls wird ein Fehler ausgel√∂st.  
  
 Wenn die Tabelle partitioniert ist, muss die FILESTREAM_ON-Klausel eingeschlossen werden und ein Partitionsschema von FILESTREAM-Dateigruppen angeben, das die gleiche Partitionsfunktion und die gleichen Partitionsspalten wie das Partitionsschema der Tabelle enth√§lt. Andernfalls wird ein Fehler ausgel√∂st.  
  
 Wenn die Tabelle nicht partitioniert ist, kann die FILESTREAM-Spalte nicht partitioniert werden. Die FILESTREAM-Daten f√ºr die Tabelle m√ºssen in einer einzigen Dateigruppe gespeichert werden, die in der FILESTREAM_ON-Klausel angegeben wird.  
  
 FILESTREAM_ON NULL kann in einer CREATE INDEX-Anweisung angegeben werden, wenn ein gruppierter Index erstellt wird und die Tabelle keine FILESTREAM-Spalte enth√§lt.  
  
 Weitere Informationen finden Sie unter [FILESTREAM &#40;SQL Server&#41;](../../relational-databases/blob/filestream-sql-server.md).  
  
 ROWGUIDCOL  
 Gibt an, dass die neue Spalte eine Spalte mit Zeilen-GUIDs ist. Nur eine **uniqueidentifier**-Spalte pro Tabelle kann als ROWGUIDCOL-Spalte gekennzeichnet werden. Nach der Anwendung der ROWGUIDCOL-Eigenschaft kann mit $ROWGUID auf die Spalte verwiesen werden. Die ROWGUIDCOL-Eigenschaft kann nur einer **uniqueidentifier**-Spalte zugewiesen werden. Spalten eines benutzerdefinierten Datentyps k√∂nnen nicht mit ROWGUIDCOL gekennzeichnet werden.  
  
 Die ROWGUIDCOL-Eigenschaft erzwingt keine Eindeutigkeit der in der Spalte gespeicherten Werte. ROWGUIDCOL erzeugt auch nicht automatisch Werte f√ºr neue Zeilen, die in die Tabelle eingef√ºgt werden. Zum Generieren eindeutiger Werte f√ºr jede Spalte verwenden Sie entweder die Funktion [NEWID](../../t-sql/functions/newid-transact-sql.md) oder [NEWSEQUENTIALID](../../t-sql/functions/newsequentialid-transact-sql.md) in [INSERT](../../t-sql/statements/insert-transact-sql.md)-Anweisungen, oder verwenden Sie diese Funktionen als Standardwert f√ºr die Spalte.  
  
 ENCRYPTED WITH  
 Gibt Verschl√ºsselungsspalten mit dem Feature [Always Encrypted](../../relational-databases/security/encryption/always-encrypted-database-engine.md) an.  
  
 COLUMN_ENCRYPTION_KEY = *key_name*  
 Gibt Spaltenverschl√ºsselungsschl√ºssel an. Weitere Informationen finden Sie unter [CREATE COLUMN ENCRYPTION KEY &#40;Transact-SQL&#41;](../../t-sql/statements/create-column-encryption-key-transact-sql.md).  
  
 ENCRYPTION_TYPE = { DETERMINISTIC | RANDOMIZED }  
 Die**deterministische Verschl√ºsselung** verwendet eine Methode, die immer denselben verschl√ºsselten Wert f√ºr jeden angegebenen Klartextwert generiert. Die Verwendung der deterministischen Verschl√ºsselung erm√∂glicht die Suche mit einer Gleichheits√ºberpr√ºfung, das Gruppieren und das Verkn√ºpfen von Tabellen mit Gleichheitsjoins, basierend auf verschl√ºsselten Werten. Jedoch erlaubt sie nicht autorisierten Benutzern m√∂glicherweise, Informationen zu verschl√ºsselten Werten zu erraten, indem sie die Muster in den verschl√ºsselten Spalten untersuchen. Das Verkn√ºpfen zweier Tabellen mit deterministisch verschl√ºsselten Spalten ist nur m√∂glich, wenn die Spalten mit demselben Spaltenverschl√ºsselungsschl√ºssel verschl√ºsselt sind. Die deterministische Verschl√ºsselung muss eine Spaltensortierung mit einer binary2-Sortierreihenfolge f√ºr Zeichenspalten verwenden.  
  
 Die**zuf√§llige Verschl√ºsselung** verwendet eine Methode, die Daten in einer weniger vorhersagbaren Weise verschl√ºsselt. Die zuf√§llige Verschl√ºsselung ist sicherer, verhindert aber die Gleichheitssuche, Gruppierung und Verkn√ºpfung f√ºr verschl√ºsselte Spalten. Spalten mit zuf√§lliger Verschl√ºsselung k√∂nnen nicht indiziert werden.  
  
 Verwenden Sie die deterministische Verschl√ºsselung f√ºr Spalten, die Such- oder Gruppierungsparameter enthalten, so z.B. eine Personalausweisnummer. Verwenden Sie die zuf√§llige Datenverschl√ºsselung f√ºr Daten (z.B. Kreditkartennummern), die nicht mit anderen Datens√§tzen gruppiert oder in Jointabellen verwendet werden und nach denen nicht gesucht wird, wenn andere Spalten verwendet werden (z.B. Transaktionsnummern), um die Zeile zu suchen, die die betreffende verschl√ºsselte Spalte enth√§lt.  
  
 Spalten m√ºssen einen qualifizierenden Datentyp aufweisen.  
  
 ALGORITHM  
 Muss **'AEAD_AES_256_CBC_HMAC_SHA_256'** sein.  
  
 Weitere Informationen einschlie√ülich Featureeinschr√§nkungen finden Sie unter [Always Encrypted &#40;Datenbank-Engine&#41;](../../relational-databases/security/encryption/always-encrypted-database-engine.md).  
  
 **Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].  
  
 SPARSE  
 Gibt an, dass die Spalte eine Sparsespalte ist. Der Speicher f√ºr Sparsespalten ist f√ºr NULL-Werte optimiert. Spalten mit geringer Dichte k√∂nnen nicht als NOT NULL festgelegt werden. Weitere Einschr√§nkungen und Informationen zu Sparsespalten finden Sie unter [Verwenden von Sparsespalten](../../relational-databases/tables/use-sparse-columns.md).  
  
 MASKED WITH ( FUNCTION = ' *mask_function* ')  
 **Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].  
  
 Gibt eine dynamische Datenmaske an. *mask_function* ist der Name der Maskierungsfunktion mit den entsprechenden Parametern. Drei Optionen stehen zur Verf√ºgung:  
  
-   default()  
  
-   email()  
  
-   partial()  
  
-   random()  
  
 Weitere Informationen zu Funktionsparametern finden Sie im Artikel zur [dynamischen Datenmaskierung](../../relational-databases/security/dynamic-data-masking.md).  
  
 FILESTREAM  
   
**Gilt f√ºr**: [!INCLUDE[ssNoVersion](../../includes/ssnoversion.md)].

 Gilt nur f√ºr **varbinary(max)**-Spalten. Gibt den FILESTREAM-Speicher f√ºr die **varbinary(max)**-BLOB-Daten an.  
  
 Die Tabelle muss auch eine Spalte mit dem Datentyp **uniqueidentifier** aufweisen, der das ROWGUIDCOL-Attribut enth√§lt. Diese Spalte darf keine NULL-Werte zulassen und muss eine UNIQUE- oder eine PRIMARY KEY-Einschr√§nkung f√ºr einzelne Spalten enthalten. Der GUID-Wert f√ºr die Spalte muss entweder beim Einf√ºgen von Daten von einer Anwendung oder durch eine DEFAULT-Einschr√§nkung mit der NEWID ()-Funktion bereitgestellt werden.  
  
 Die Spalte ROWGUIDCOL kann nicht gel√∂scht, und die zugeh√∂rigen Einschr√§nkungen k√∂nnen nicht ge√§ndert werden, wenn f√ºr die Tabelle eine FILESTREAM-Spalte definiert ist. Die Spalte ROWGUIDCOL kann nur gel√∂scht werden, nachdem die letzte FILESTREAM-Spalte gel√∂scht wurde.  
  
 Wenn das FILESTREAM-Speicherattribut f√ºr eine Spalte angegeben wird, werden alle Werte dieser Spalte in einem FILESTREAM-Datencontainer des Dateisystems gespeichert.  
  
 COLLATE *collation_name*  
 Gibt die Sortierung f√ºr die Spalte an. Als Sortierungsname kann entweder der Name einer Windows-Sortierreihenfolge oder ein SQL-Sortierungsname verwendet werden. *collation_name* ist nur f√ºr Spalten mit den folgenden Datentypen anwendbar: **char**, **varchar**, **text**, **nchar**, **nvarchar** und **ntext**. Wenn collation_name nicht angegeben ist, wird der Spalte die Sortierung des benutzerdefinierten Datentyps zugewiesen, wenn es sich um eine Spalte von einem benutzerdefinierten Datentyp handelt, oder es wird die Standardsortierung der Datenbank zugewiesen.  
  
 Weitere Informationen zu den Windows- und SQL-Sortierungsnamen finden Sie unter [Name der Windows-Sortierung](../../t-sql/statements/windows-collation-name-transact-sql.md) und [SQL Server-Sortierungsname](../../t-sql/statements/sql-server-collation-name-transact-sql.md).  
  
 Weitere Informationen zur COLLATE-Klausel finden Sie unter [COLLATE &#40;Transact-SQL&#41;](~/t-sql/statements/collations.md).  
  
 CONSTRAINT  
 Ein optionales Schl√ºsselwort, das den Anfang der Definition einer PRIMARY KEY-, NOT NULL-, UNIQUE-, FOREIGN KEY- oder CHECK-Einschr√§nkung anzeigt.  
  
 *constraint_name*  
 Der Name einer Einschr√§nkung. Einschr√§nkungsnamen m√ºssen innerhalb des Schemas, zu dem die Tabelle geh√∂rt, eindeutig sein.  
  
 NULL | NOT NULL  
 Bestimmt, ob NULL-Werte in der Spalte zul√§ssig sind. NULL ist genau genommen keine Einschr√§nkung, kann jedoch wie NOT NULL verwendet werden. NOT NULL kann nur f√ºr berechnete Spalten angegeben werden, wenn auch PERSISTED angegeben ist.  
  
 PRIMARY KEY  
 Eine Einschr√§nkung, die die Entit√§tsintegrit√§t f√ºr eine bestimmte Spalte (oder Spalten) durch einen eindeutigen Index erzwingt. Es kann nur eine PRIMARY KEY-Einschr√§nkung pro Tabelle erstellt werden.  
  
 UNIQUE  
 Eine Einschr√§nkung, die Entit√§tsintegrit√§t f√ºr eine angegebene Spalte (oder Spalten) durch einen eindeutigen Index bereitstellt. Eine Tabelle kann mehrere UNIQUE-Einschr√§nkungen haben.  
  
 CLUSTERED | NONCLUSTERED  
 Gibt an, dass ein gruppierter oder nicht gruppierter Index f√ºr die PRIMARY KEY- oder UNIQUE-Einschr√§nkung erstellt wird. F√ºr PRIMARY KEY-Einschr√§nkungen wird standardm√§√üig CLUSTERED verwendet; f√ºr UNIQUE-Einschr√§nkungen wird standardm√§√üig NONCLUSTERED verwendet.  
  
 In einer CREATE TABLE-Anweisung kann CLUSTERED nur f√ºr eine einzige Einschr√§nkung angegeben werden. Wenn Sie CLUSTERED f√ºr eine UNIQUE-Einschr√§nkung angeben und au√üerdem eine PRIMARY KEY-Einschr√§nkung angeben, wird f√ºr PRIMARY KEY standardm√§√üig NONCLUSTERED verwendet.  
  
 Im Folgenden wird gezeigt, wie NONCLUSTERED in einer datentr√§gerbasierten Tabelle verwendet wird:  
  
```  
CREATE TABLE t1 ( c1 int, INDEX ix_1 NONCLUSTERED (c1))   
CREATE TABLE t2( c1 int INDEX ix_1 NONCLUSTERED (c1))   
CREATE TABLE t3( c1 int, c2 int INDEX ix_1 NONCLUSTERED)   
CREATE TABLE t4( c1 int, c2 int, INDEX ix_1 NONCLUSTERED (c1,c2))  
```  
  
 FOREIGN KEY REFERENCES  
 Eine Einschr√§nkung, die referenzielle Integrit√§t f√ºr die Daten in der Spalte oder den Spalten bereitstellt. FOREIGN KEY-Einschr√§nkungen erfordern, dass jeder Wert in der Spalte in den entsprechenden Spalten, auf die verwiesen wird, in der Tabelle, auf die verwiesen wird, vorhanden ist. FOREIGN KEY-Einschr√§nkungen k√∂nnen nur auf Spalten verweisen, die PRIMARY KEY- oder UNIQUE-Einschr√§nkungen in der Tabelle sind, auf die verwiesen wird; oder auf Spalten, auf die in einer UNIQUE INDEX-Einschr√§nkung in der Tabelle, auf die verwiesen wird, verwiesen wird. Fremdschl√ºssel f√ºr berechnete Spalten m√ºssen auch als PERSISTED markiert werden.  
  
 [ *schema_name***.**] *referenced_table_name*]  
 Der Name der Tabelle, auf die in der FOREIGN KEY-Einschr√§nkung verwiesen wird, sowie das Schema, zu dem sie geh√∂rt.  
  
 **(** *ref_column* [ **,**... *n* ] **)**  
 Eine Spalte oder Liste von Spalten aus der Tabelle, auf die die FOREIGN KEY-Einschr√§nkung verweist.  
  
 ON DELETE { **NO ACTION** | CASCADE | SET NULL | SET DEFAULT }  
 Gibt an, welche Aktion f√ºr Zeilen in der erstellten Tabelle ausgef√ºhrt werden soll, wenn diese Zeilen eine referenzielle Beziehung aufweisen und die Zeile, auf die verwiesen wird, aus der √ºbergeordneten Tabelle gel√∂scht wird. Der Standardwert ist NO ACTION.  
  
 NO ACTION  
 [!INCLUDE[ssDE](../../includes/ssde-md.md)] l√∂st einen Fehler aus, und f√ºr die Aktion zum L√∂schen der Zeile in der √ºbergeordneten Tabelle wird ein Rollback ausgef√ºhrt.  
  
 CASCADE  
 Wenn diese Zeile aus der √ºbergeordneten Tabelle gel√∂scht wird, werden die entsprechenden Zeilen aus der verweisenden Tabelle gel√∂scht.  
  
 SET NULL  
 Alle Werte, aus denen sich der Fremdschl√ºssel zusammensetzt, werden auf NULL festgelegt, wenn die entsprechende Zeile in der √ºbergeordneten Tabelle gel√∂scht wird. Die Fremdschl√ºsselspalten m√ºssen NULL-Werte zulassen, um diese Einschr√§nkung auszuf√ºhren.  
  
 SET DEFAULT  
 Alle Werte, aus denen sich der Fremdschl√ºssel zusammensetzt, werden auf ihre Standardwerte festgelegt, wenn die entsprechende Zeile in der √ºbergeordneten Tabelle gel√∂scht wird. Alle Fremdschl√ºsselspalten m√ºssen Standarddefinitionen aufweisen, damit diese Einschr√§nkung ausgef√ºhrt wird. Wenn eine Spalte NULL-Werte zul√§sst, und es ist kein expliziter Standardwert festgelegt, wird NULL als der implizite Standardwert f√ºr die Spalte verwendet.  
  
 Geben Sie CASCADE nicht an, wenn die Tabelle in eine Mergever√∂ffentlichung einbezogen werden soll, bei der logische Datens√§tze verwendet werden. Weitere Informationen zu logischen Datens√§tzen finden Sie unter [Gruppieren von √Ñnderungen an verkn√ºpften Zeilen mithilfe von logischen Datens√§tzen](../../relational-databases/replication/merge/group-changes-to-related-rows-with-logical-records.md).  
  
 ON DELETE CASCADE kann nicht definiert werden, wenn f√ºr ON DELETE bereits ein INSTEAD OF-Trigger f√ºr die Tabelle vorhanden ist.  
  
 In der Datenbank [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)] verf√ºgt die Tabelle **ProductVendor** beispielsweise √ºber eine referenzielle Beziehung zu der Tabelle **Vendor**. Der Fremdschl√ºssel **ProductVendor.BusinessEntityID** verweist auf den Prim√§rschl√ºssel **Vendor.BusinessEntityID**.  
  
 Wenn eine DELETE-Anweisung f√ºr eine Zeile in der Tabelle **Vendor** ausgef√ºhrt wird, und eine ON DELETE CASCADE-Aktion f√ºr **ProductVendor.BusinessEntityID** festgelegt ist, sucht [!INCLUDE[ssDE](../../includes/ssde-md.md)] nach mindestens einer abh√§ngigen Zeile in der Tabelle **ProductVendor**. Falls eine solche Zeile vorhanden ist, werden die abh√§ngigen Zeilen in der Tabelle **ProductVendor** sowie die Zeile, auf die in der Tabelle **Vendor** verwiesen wird, gel√∂scht.  
  
 Ist hingegen NO ACTION angegeben, l√∂st [!INCLUDE[ssDE](../../includes/ssde-md.md)] einen Fehler aus und f√ºhrt ein Rollback f√ºr die L√∂schaktion der **Vendor**-Zeile aus, wenn in der **ProductVendor**-Tabelle mindestens eine Zeile vorhanden ist, die auf diese Zeile verweist.  
  
 ON UPDATE { **NO ACTION** | CASCADE | SET NULL | SET DEFAULT }  
 Gibt an, welche Aktion f√ºr eine Zeile der ge√§nderten Tabelle ausgef√ºhrt werden soll, wenn diese Zeile eine referenzielle Beziehung hat und die Zeile, auf die verwiesen wird, in der √ºbergeordneten Tabelle aktualisiert wird. Der Standardwert ist NO ACTION.  
  
 NO ACTION  
 [!INCLUDE[ssDE](../../includes/ssde-md.md)] l√∂st einen Fehler aus, und f√ºr die Updateaktion der Zeile in der √ºbergeordneten Tabelle wird ein Rollback ausgef√ºhrt.  
  
 CASCADE  
 Wenn diese Zeile in der √ºbergeordneten Tabelle aktualisiert wird, werden die entsprechenden Zeilen in der verweisenden Tabelle aktualisiert.  
  
 SET NULL  
 Alle Werte, aus denen sich der Fremdschl√ºssel zusammensetzt, werden auf NULL festgelegt, wenn die entsprechende Zeile in der √ºbergeordneten Tabelle aktualisiert wird. Die Fremdschl√ºsselspalten m√ºssen NULL-Werte zulassen, um diese Einschr√§nkung auszuf√ºhren.  
  
 SET DEFAULT  
 Alle Werte, aus denen sich der Fremdschl√ºssel zusammensetzt, werden auf die Standardwerte festgelegt, wenn die entsprechende Zeile in der √ºbergeordneten Tabelle aktualisiert wird. Alle Fremdschl√ºsselspalten m√ºssen Standarddefinitionen aufweisen, damit diese Einschr√§nkung ausgef√ºhrt wird. Wenn eine Spalte NULL-Werte zul√§sst, und es ist kein expliziter Standardwert festgelegt, wird NULL als der implizite Standardwert f√ºr die Spalte verwendet.  
  
 Geben Sie CASCADE nicht an, wenn die Tabelle in eine Mergever√∂ffentlichung einbezogen werden soll, bei der logische Datens√§tze verwendet werden. Weitere Informationen zu logischen Datens√§tzen finden Sie unter [Gruppieren von √Ñnderungen an verkn√ºpften Zeilen mithilfe von logischen Datens√§tzen](../../relational-databases/replication/merge/group-changes-to-related-rows-with-logical-records.md).  
  
 ON UPDATE CASCADE, SET NULL oder SET DEFAULT k√∂nnen nicht definiert werden, wenn f√ºr ON UPDATE schon ein INSTEAD OF-Trigger f√ºr die Tabelle vorhanden ist, die ge√§ndert wird.  
  
 Beispielsweise verf√ºgt die Tabelle **ProductVendor** in der Datenbank [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)] √ºber eine referenzielle Beziehung zu der Tabelle **Vendor**: Der Fremdschl√ºssel **ProductVendor.BusinessEntity** verweist auf den Prim√§rschl√ºssel **Vendor.BusinessEntityID**.  
  
 Wenn eine UPDATE-Anweisung f√ºr eine Zeile in der Tabelle **Vendor** ausgef√ºhrt wird, und eine ON UPDATE CASCADE-Aktion f√ºr **ProductVendor.BusinessEntityID** festgelegt ist, sucht [!INCLUDE[ssDE](../../includes/ssde-md.md)] nach mindestens einer abh√§ngigen Zeile in der Tabelle **ProductVendor**. Falls eine solche Zeile vorhanden ist, werden die abh√§ngigen Zeilen in der Tabelle **ProductVendor** sowie die Zeile, auf die in der Tabelle **Vendor** verwiesen wird, aktualisiert.  
  
 Ist hingegen NO ACTION angegeben, l√∂st [!INCLUDE[ssDE](../../includes/ssde-md.md)] einen Fehler aus und f√ºhrt f√ºr die Updateaktion der **Vendor**-Zeile ein Rollback aus, wenn in der **ProductVendor**-Tabelle mindestens eine Zeile vorhanden ist, die auf diese Zeile verweist.  
  
 CHECK  
 Eine Einschr√§nkung, die Dom√§nenintegrit√§t erzwingt, indem die m√∂glichen Eingabewerte f√ºr eine oder mehrere Spalten beschr√§nkt wird. CHECK-Einschr√§nkungen f√ºr berechnete Spalten m√ºssen auch als PERSISTED markiert werden.  
  
 *logical_expression*  
 Ein logischer Ausdruck, der TRUE oder FALSE zur√ºckgibt. Aliasdatentypen k√∂nnen nicht Teil des Ausdrucks sein.  
  
 *column*  
 Eine Spalte oder Liste von Spalten in Klammern, die in Tabelleneinschr√§nkungen verwendet wird, um anzuzeigen, welche Spalten in der Einschr√§nkungsdefinition verwendet werden.  
  
 [ **ASC** | DESC ]  
 Gibt die Reihenfolge an, in der die Spalte oder die Spalten, die in der Tabelleneinschr√§nkung enthalten sind, sortiert werden. Die Standardeinstellung ist ASC.  
  
 *partition_scheme_name*  
 Der Name des Partitionsschemas, das die Dateigruppen definiert, denen die Partitionen einer partitionierten Tabelle zugeordnet werden. Das Partitionsschema muss in der Datenbank vorhanden sein.  
  
 [ *partition_column_name***.** ]  
 Gibt die Spalte an, auf deren Grundlage eine partitionierte Tabelle partitioniert wird. Die Spalte muss in Bezug auf Datentyp, L√§nge und Genauigkeit mit der Spalte √ºbereinstimmen, die in *partition_scheme_name* verwendet wird. Berechnete Spalten, die in eine Partitionsfunktion einbezogen werden, m√ºssen explizit als PERSISTED gekennzeichnet sein.  
  
> [!IMPORTANT]  
>  Es wird empfohlen, NOT NULL f√ºr die Partitionierungsspalte von partitionierten Tabellen sowie von nicht partitionierten Tabellen anzugeben, die als Quelle oder Ziel f√ºr ALTER TABLE...SWITCH-Vorg√§nge fungieren. Damit stellen Sie sicher, dass mit CHECK-Einschr√§nkungen f√ºr Partitionierungsspalten keine √úberpr√ºfung auf NULL-Werte ausgef√ºhrt werden muss.  
  
 WITH FILLFACTOR **=***fillfactor*  
 Gibt an, wie weit das [!INCLUDE[ssDE](../../includes/ssde-md.md)] die einzelnen Indexseiten f√ºllen soll, die zum Speichern der Indexdaten verwendet werden. Vom Benutzer angegebene *fillfactor*-Werte k√∂nnen Zahlen von 1 bis 100 sein. Wenn kein Wert angegeben ist, lautet der Standardwert 0. Die F√ºllfaktorwerte 0 und 100 sind in jeder Hinsicht identisch.  
  
> [!IMPORTANT]  
>  Das Verwenden von WITH FILLFACTOR = *fillfactor* als einzige Indexoption, die f√ºr die PRIMARY KEY- oder UNIQUE-Einschr√§nkungen gilt, wird hier aus Gr√ºnden der Abw√§rtskompatibilit√§t weiterhin dokumentiert. In zuk√ºnftigen Releases wird dies jedoch nicht mehr der Fall sein.  
  
 *column_set_name* XML COLUMN_SET FOR ALL_SPARSE_COLUMNS  
 Der Name des Spaltensatzes. Bei einem Spaltensatz handelt es sich um eine nicht typisierte XML-Darstellung, die alle Sparsespalten einer Tabelle in einer strukturierten Ausgabe kombiniert. Weitere Informationen zu Spaltens√§tzen finden Sie unter [Verwenden von Spaltens√§tzen](../../relational-databases/tables/use-column-sets.md).  
  
 PERIOD FOR SYSTEM_TIME (*system_start_time_column_name* , *system_end_time_column_name* )  
   
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 Gibt die Namen der Spalten an, die das System verwendet, um den Zeitraum aufzuzeichnen, f√ºr den ein Datensatz g√ºltig ist. Verwenden Sie dieses Argument zusammen mit den Argumenten GENERATED ALWAYS AS ROW { START | END } und WITH SYSTEM_VERSIONING = ON, um die Versionsverwaltung durch das System f√ºr eine Tabelle zu aktivieren. Weitere Informationen finden Sie unter [Temporal Tables](../../relational-databases/tables/temporal-tables.md).  
  
 COMPRESSION_DELAY  
   
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 Diese Verz√∂gerung gibt bei einer speicheroptimierten Tabelle die minimale Anzahl von Minuten an, die eine Zeile in der Tabelle unver√§ndert bleiben muss, bevor sie f√ºr die Komprimierung in den Columnstore-Index geeignet ist. SQL Server w√§hlt spezifische Zeilen f√ºr die Komprimierung gem√§√ü dem Zeitpunkt der letzten Aktualisierung aus. Wenn Zeilen innerhalb von zwei Stunden h√§ufig ge√§ndert werden, k√∂nnen Sie beispielsweise ‚ÄûCOMPRESSION_DELAY = 120 Minutes‚Äú festlegen, um sicherzustellen, dass Zeilen vor dem Komprimieren aktualisiert wurden.  
  
 DELAY gibt bei einer datentr√§gerbasierten Tabelle die minimale Anzahl von Minuten an, die eine Deltazeilengruppe im Zustand CLOSED in der Delta-Zeilengruppe verbringen muss, bevor SQL Server sie in die komprimierte Zeilengruppe komprimieren kann. Da Einf√ºgungs- und Aktualisierungszeiten in datentr√§gerbasierten Tabellen nicht f√ºr einzelne Zeilen nachverfolgt werden, wird in SQL Server die Verz√∂gerung auf Delta-Zeilengruppen im Zustand CLOSED angewendet.  
  
 Der Standardwert ist 0 Minuten.  
  
 Empfehlungen zur Verwendung von COMPRESSION_DELAY finden Sie unter [Erste Schritte mit Columnstore f√ºr operative Echtzeitanalyse](../../relational-databases/indexes/get-started-with-columnstore-for-real-time-operational-analytics.md).  
  
 \<table_option> ::= Gibt eine oder mehrere Tabellenoptionen an.  
  
 DATA_COMPRESSION  
 Gibt die Datenkomprimierungsoption f√ºr die angegebene Tabelle, die Partitionsnummer oder den Bereich von Partitionen an. Folgende Optionen stehen zur Verf√ºgung:  
  
 NONE  
 Die Tabelle oder die angegebenen Partitionen werden nicht komprimiert.  
  
 ROW  
 Die Tabelle oder die angegebenen Partitionen werden mit Zeilenkomprimierung komprimiert.  
  
 PAGE  
 Die Tabelle oder die angegebenen Partitionen werden mit Seitenkomprimierung komprimiert.  
  
 COLUMNSTORE  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 Gilt nur f√ºr columnstore-Indizes, einschlie√ülich nicht gruppierter und gruppierter columnstore-Indizes. COLUMNSTORE gibt an, dass die Komprimierung mit der leistungsf√§higsten Columnstore-Komprimierung ausgef√ºhrt werden soll. Dies ist die g√§ngige Methode.  
  
 COLUMNSTORE_ARCHIVE  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].  
  
 Gilt nur f√ºr columnstore-Indizes, einschlie√ülich nicht gruppierter und gruppierter columnstore-Indizes. Durch COLUMNSTORE_ARCHIVE wird die Tabelle oder Partition weiter in eine geringere Gr√∂√üe komprimiert. Dies empfiehlt sich bei der Archivierung und in Situationen, in denen es auf eine geringere Speichergr√∂√üe und nicht auf den zus√§tzlichen Zeitaufwand f√ºr das Speichern und Abrufen ankommt.  
  
 Weitere Informationen zur Datenkomprimierung finden Sie unter [Datenkomprimierung](../../relational-databases/data-compression/data-compression.md).  
  
 ON PARTITIONS **(** { `<partition_number_expression>` | [ **,**...*n* ] **)**  
 Gibt die Partitionen an, f√ºr die die DATA_COMPRESSION-Einstellung gilt. Wenn die Tabelle nicht partitioniert ist, erzeugt das ON PARTITIONS-Argument einen Fehler. Wenn die ON PARTITIONS-Klausel nicht angegeben wird, gilt die DATA_COMPRESSION-Option f√ºr alle Partitionen einer partitionierten Tabelle.  
  
 *partition_number_expression* kann auf folgenden Weisen angegeben werden:  
  
-   Geben Sie die Partitionsnummer einer Partition an, beispielsweise: ON PARTITIONS (2).  
  
-   Geben Sie die Partitionsnummern mehrerer einzelner Partitionen durch Trennzeichen getrennt an, beispielsweise: ON PARTITIONS (1, 5).  
  
-   Geben Sie sowohl Bereiche als auch einzelne Partitionen an, zum Beispiel: ON PARTITIONS (2, 4, 6 TO 8).  
  
 F√ºr `<range>` k√∂nnen durch das Wort TO getrennte Partitionsnummern angegeben werden, beispielsweise: ON PARTITIONS (6 TO 8).  
  
 Wenn Sie f√ºr verschiedene Partitionen unterschiedliche Datenkomprimierungstypen festlegen m√∂chten, geben Sie die Option DATA_COMPRESSION mehrmals an, beispielsweise:  
  
```  
WITH   
(  
DATA_COMPRESSION = NONE ON PARTITIONS (1),   
DATA_COMPRESSION = ROW ON PARTITIONS (2, 4, 6 TO 8),   
DATA_COMPRESSION = PAGE ON PARTITIONS (3, 5)  
)  
```  
  
 \<index_option> ::=  
 Gibt eine oder mehrere Indexoptionen an. Eine vollst√§ndige Beschreibung dieser Optionen finden Sie unter [CREATE INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/create-index-transact-sql.md).  
  
 PAD_INDEX = { ON | **OFF** }  
 Bei der Einstellung ON wird der durch FILLFACTOR angegebene Prozentsatz des freien Speicherplatzes auf die Zwischenebenenseiten des Indexes angewendet. Wenn die Einstellung OFF verwendet wird oder kein FILLFACTOR-Wert angegeben wurde, werden die Zwischenebenenseiten fast bis zu ihrer Kapazit√§tsgrenze gef√ºllt, wobei ausreichend Speicherplatz f√ºr mindestens eine Zeile mit der maximal f√ºr diesen Index m√∂glichen Gr√∂√üe frei bleibt; diese ergibt sich aus der Schl√ºsselmenge auf den Zwischenseiten. Der Standardwert ist OFF.  
  
 FILLFACTOR **=***fillfactor*  
 Gibt einen Prozentwert an, der dem F√ºllfaktor entspricht. Dieser Faktor legt fest, wie weit die [!INCLUDE[ssDE](../../includes/ssde-md.md)] die Blattebene jeder Indexseite w√§hrend der Indexerstellung oder -√§nderung auff√ºllen soll.  *fillfactor* muss ein ganzzahliger Wert zwischen 1 und 100 sein. Die Standardeinstellung ist 0. Die F√ºllfaktorwerte 0 und 100 sind in jeder Hinsicht identisch.  
  
 IGNORE_DUP_KEY = { ON | **OFF** }  
 Gibt die Fehlermeldung an, wenn ein Einf√ºgevorgang versucht, doppelte Schl√ºsselwerte in einen eindeutigen Index einzuf√ºgen. Die IGNORE_DUP_KEY-Option gilt nur f√ºr Einf√ºgevorg√§nge nach dem Erstellen oder Neuerstellen des Index. Beim Ausf√ºhren von [CREATE INDEX](../../t-sql/statements/create-index-transact-sql.md), [ALTER INDEX](../../t-sql/statements/alter-index-transact-sql.md) oder [UPDATE](../../t-sql/queries/update-transact-sql.md) hat die Option keine Auswirkungen. Der Standardwert ist OFF.  
  
 ON  
 Eine Warnmeldung wird ausgegeben, wenn doppelte Schl√ºsselwerte in einen eindeutigen Index eingef√ºgt werden. Es schlagen nur die Zeilen fehl, die gegen die Eindeutigkeitseinschr√§nkung versto√üen.  
  
 OFF  
 Eine Fehlermeldung wird ausgegeben, wenn doppelte Schl√ºsselwerte in einen eindeutigen Index eingef√ºgt werden. F√ºr den gesamten INSERT-Vorgang wird ein Rollback ausgef√ºhrt.  
  
 IGNORE_DUP_KEY kann f√ºr Indizes, die f√ºr eine Sicht erstellt werden, nicht eindeutige Indizes, XML-Indizes, r√§umliche und gefilterte Indizes nicht auf ON festgelegt werden.  
  
 Um IGNORE_DUP_KEY anzuzeigen, verwenden Sie [sys.indexes](../../relational-databases/system-catalog-views/sys-indexes-transact-sql.md).  
  
 In abw√§rtskompatibler Syntax ist WITH IGNORE_DUP_KEY gleichwertig mit WITH IGNORE_DUP_KEY = ON.  
  
 STATISTICS_NORECOMPUTE **=** { ON | **OFF** }  
 Bei der Einstellung ON werden veraltete Indexstatistiken nicht automatisch neu berechnet. Bei der Einstellung OFF sind automatische Statistikupdates aktiviert. Der Standardwert ist OFF.  
  
 ALLOW_ROW_LOCKS **=** { **ON** | OFF }  
 Bei der Einstellung ON sind Zeilensperren beim Zugriff auf den Index zul√§ssig. Das [!INCLUDE[ssDE](../../includes/ssde-md.md)] bestimmt, wann Zeilensperren verwendet werden. Bei OFF werden Zeilensperren nicht verwendet. Der Standardwert ist ON.  
  
 ALLOW_PAGE_LOCKS **=** { **ON** | OFF }  
 Bei der Einstellung ON sind Seitensperren beim Zugriff auf den Index zul√§ssig. Das [!INCLUDE[ssDE](../../includes/ssde-md.md)] bestimmt, wann Seitensperren verwendet werden. Bei der Einstellung OFF werden Seitensperren nicht verwendet. Der Standardwert ist ON.  
  
 FILETABLE_DIRECTORY = *directory_name*  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
  
 Gibt den Windows-kompatiblen FileTable-Verzeichnisnamen an. Dieser Name sollte f√ºr alle FileTable-Verzeichnisnamen in der Datenbank eindeutig sein. Bei Eindeutigkeitsvergleichen wird unabh√§ngig von den Sortiereinstellungen die Gro√ü-/Kleinschreibung nicht beachtet. Wenn dieser Wert nicht angegeben ist, wird Name der Dateitabelle verwendet.  
  
 FILETABLE_COLLATE_FILENAME = { *collation_name* | database_default }  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
  
 Gibt den Namen der Sortierung an, die auf die **Name** -Spalte in der FileTable angewendet werden soll. Zur Einhaltung der Windows-Dateinamensemantik darf bei der Sortierung die Gro√ü-/Kleinschreibung nicht beachtet werden. Wenn dieser Wert nicht angegeben ist, wird die Standardsortierung f√ºr die Datenbank verwendet. Wenn bei der Datenbank-Standardsortierung die Gro√ü-/Kleinschreibung beachtet wird, wird ein Fehler ausgel√∂st, und der CREATE TABLE-Vorgang kann nicht durchgef√ºhrt werden.  
  
 *collation_name*  
 Der Name einer Sortierung, bei der die Gro√ü-/Kleinschreibung nicht beachtet wird.  
  
 database_default  
 Gibt an, dass die Standardsortierung f√ºr die Datenbank verwendet werden soll. Bei dieser Sortierung darf die Gro√ü-/Kleinschreibung nicht beachtet werden.  
  
 FILETABLE_PRIMARY_KEY_CONSTRAINT_NAME = *constraint_name*  
   
**Gilt f√ºr**: [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
  
 Gibt den Namen an, der f√ºr die Prim√§rschl√ºsseleinschr√§nkung verwendet werden soll, die automatisch f√ºr die FileTable erstellt wird. Wenn dieser Wert nicht angegeben ist, wird ein Name f√ºr die Einschr√§nkung generiert.  
  
 FILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME = *constraint_name*  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
  
 Gibt den Namen an, der f√ºr die eindeutige Einschr√§nkung verwendet werden soll, die automatisch f√ºr die Spalte **stream_id** der FileTable erstellt wird. Wenn dieser Wert nicht angegeben ist, wird ein Name f√ºr die Einschr√§nkung generiert.  
  
 FILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME = *constraint_name*  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)]. 
  
 Gibt den Namen an, der f√ºr die eindeutige Einschr√§nkung verwendet werden soll, die automatisch f√ºr die Spalten **parent_path_locator** und **name** in der FileTable erstellt wird. Wenn dieser Wert nicht angegeben ist, wird ein Name f√ºr die Einschr√§nkung generiert.  
  
 SYSTEM_VERSIONING **=** ON [ ( HISTORY_TABLE **=** *schema_name* .  *history_table_name* [, DATA_CONSISTENCY_CHECK **=** { **ON** | OFF } ] ) ]  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].   
  
 Erm√∂glicht die Systemversionsverwaltung der Tabelle, wenn die Einschr√§nkungsanforderungen f√ºr den Datentyp, die NULL-Zul√§ssigkeit und den Prim√§rschl√ºssel erf√ºllt werden. Wenn das Argument **HISTORY_TABLE** nicht verwendet wird, generiert das System eine neue Verlaufstabelle, die dem Schema der aktuellen Tabelle in der gleichen Dateigruppe der aktuellen Tabelle entspricht, erstellt eine Verbindung zwischen den beiden Tabellen und erm√∂glicht dem System, den Verlauf von jedem Datensatz der aktuellen Tabelle in der Verlaufstabelle aufzuzeichnen. Der Name dieser Verlaufstabelle ist dann `MSSQL_TemporalHistoryFor<primary_table_object_id>`. Standardm√§√üig ist die Verlaufstabelle **PAGE** -komprimiert. Das Argument HISTORY_TABLE wird verwendet, um eine Verbindung zu einer vorhandenen Verlaufstabelle zu erstellen und diese zu verwenden. Die Verbindung wird zwischen der aktuellen Tabelle und der angegebenen Tabelle hergestellt. Falls die aktuelle Tabelle partitioniert wurde, kann die Verlaufstabelle auf der Standarddateigruppe erstellt werden, da die Partitionierungskonfiguration nicht automatisch von der aktuellen auf die Verlaufstabelle repliziert wird. Falls der Name einer Verlaufstabelle w√§hrend der Erstellung der Verlaufstabelle angegeben wird, m√ºssen Sie das Schema und den Tabellennamen angeben. Wenn Sie einen Link zu einer vorhandenen Verlaufstabelle erstellen, k√∂nnen Sie eine Datenkonsistenzpr√ºfung durchf√ºhren. Diese Datenkonsistenzpr√ºfung stellt sicher, dass vorhandene Datens√§tze nicht √ºberlappen. Die Datenkonsistenzpr√ºfung ist standardm√§√üig aktiviert. Verwenden Sie dieses Argument zusammen mit den Argumenten PERIOD FOR SYSTEM_TIME und GENERATED ALWAYS AS ROW { START | END }, um die Systemversionsverwaltung f√ºr eine Tabelle zu aktivieren. Weitere Informationen finden Sie unter [Temporal Tables](../../relational-databases/tables/temporal-tables.md).  
  
 REMOTE_DATA_ARCHIVE = { ON [ ( *table_stretch_options* [,...n] ) ] | OFF ( MIGRATION_STATE = PAUSED ) }  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].  
  
 Erstellt eine neue Tabelle, f√ºr die Stretch Database aktiviert oder deaktiviert ist. Weitere Informationen finden Sie unter [Stretch Database](../../sql-server/stretch-database/stretch-database.md).  
  
 **Aktivieren von Stretch Database f√ºr eine Tabelle**  
  
 Wenn Sie Stretch durch Angeben von `ON` f√ºr eine Tabelle aktivieren, k√∂nnen Sie optional `MIGRATION_STATE = OUTBOUND` festlegen, um sofort mit dem Migrieren von Daten zu beginnen, oder Sie legen `MIGRATION_STATE = PAUSED` fest, um die Datenmigration zu verz√∂gern. Der Standardwert lautet `MIGRATION_STATE = OUTBOUND`. Weitere Informationen √ºber das Aktivieren von Stretch f√ºr eine Tabelle finden Sie unter [Aktivieren von Stretch Database f√ºr eine Tabelle](../../sql-server/stretch-database/enable-stretch-database-for-a-table.md).  
  
 **Voraussetzungen**. Sie m√ºssen Stretch auf dem Server und auf der Datenbank aktivieren, bevor Sie Stretch f√ºr eine Tabelle aktivieren k√∂nnen. Weitere Informationen finden Sie unter [Enable Stretch Database for a database](../../sql-server/stretch-database/enable-stretch-database-for-a-database.md).  
  
 **Berechtigungen**. Zum Aktivieren von Stretch f√ºr eine Datenbank oder eine Tabelle ben√∂tigen Sie die ‚Äûdb_owner‚Äú-Berechtigungen. Zum Aktivieren von Stretch f√ºr eine Tabelle ben√∂tigen Sie auch die ALTER-Berechtigungen f√ºr die Tabelle.  
  
 [ FILTER_PREDICATE = { null | *predicate* } ]  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)].  
  
 Gibt optional ein Filterpr√§dikat zum Ausw√§hlen der Zeilen an, die aus einer Tabelle migriert werden sollen, die sowohl Verlaufsdaten als auch aktuelle Daten enth√§lt. Das Pr√§dikat muss eine deterministische Inline-Tabellenwertfunktion aufrufen. Weitere Informationen finden Sie unter [Aktivieren von Stretch Database f√ºr eine Tabelle](../../sql-server/stretch-database/enable-stretch-database-for-a-table.md) und [Ausw√§hlen zu migrierender Zeilen mithilfe einer Filterfunktion](../../sql-server/stretch-database/select-rows-to-migrate-by-using-a-filter-function-stretch-database.md). 
   
> [!IMPORTANT]  
>  Wenn Sie ein schwaches Filterpr√§dikat angeben, wird die Datenmigration ebenfalls unzureichend ausgef√ºhrt. Stretch-Datenbank wendet das Filterpr√§dikat √ºber den CROSS APPLY-Operator auf die Tabelle an.  
  
 Wenn Sie kein Filterpr√§dikat angeben, wird die gesamte Tabelle migriert.  
  
 Wenn Sie ein Filterpr√§dikat angeben, m√ºssen Sie auch *MIGRATION_STATE* angeben.  
  
 MIGRATION_STATE = { OUTBOUND |  INBOUND | PAUSED }  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und Azure SQL. 
  
-   Geben Sie `OUTBOUND` an, um Daten von SQL Server zu Azure zu migrieren.  
  
-   Geben Sie `INBOUND` an, um Remotedaten f√ºr die Tabelle aus Azure zur√ºck zu SQL Server zu migrieren und Stretch f√ºr die Tabelle zu deaktivieren. Weitere Informationen finden Sie unter [Deaktivieren von Stretch Database und Zur√ºckholen von Remotedaten](../../sql-server/stretch-database/disable-stretch-database-and-bring-back-remote-data.md).  
  
     Dieser Vorgang verursacht Daten√ºbertragungskosten und kann nicht abgebrochen werden.  
  
-   Geben Sie `PAUSED` an, um die Datenmigration zu pausieren oder nach hinten zu verschieben. Weitere Informationen finden Sie unter [Anhalten und Fortsetzen der Datenmigration &#40;Stretch Database&#41;](../../sql-server/stretch-database/pause-and-resume-data-migration-stretch-database.md).  
  
 MEMORY_OPTIMIZED  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].  
  
 Der Wert ON gibt an, dass die Tabelle speicheroptimiert ist. Speicheroptimierte Tabellen sind Teil des Features ‚ÄûIn-Memory OLTP‚Äú, das verwendet wird, um die Leistung der Transaktionsverarbeitung zu optimieren. Eine Einf√ºhrung in In-Memory OLTP finden Sie unter [Schnellstart 1: In-Memory-OLTP-Technologien f√ºr h√∂here Transact-SQL-Leistung](../../relational-databases/in-memory-oltp/survey-of-initial-areas-in-in-memory-oltp.md). Ausf√ºhrliche Informationen zu speicheroptimierten Tabellen finden Sie unter [Speicheroptimierte Tabellen](../../relational-databases/in-memory-oltp/memory-optimized-tables.md).  
  
 Der Standardwert OFF gibt an, dass die Tabelle auf einem Datentr√§ger basiert.  
  
 DURABILITY  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].   
  
 Der Wert von SCHEMA_AND_DATA gibt an, dass die Tabelle dauerhaft ist, d.h. √Ñnderungen werden auf dem Datentr√§ger beibehalten und √ºberstehen Neustarts und Failover.  SCHEMA_AND_DATA ist der Standardwert.  
  
 Der Wert von SCHEMA_ONLY gibt an, dass die Tabelle nicht dauerhaft ist. Das Tabellenschema wird beibehalten, aber Datenupdates werden nach einem Neustart oder Failover der Datenbank nicht beibehalten. DURABILITY=SCHEMA_ONLY ist nicht mit MEMORY_OPTIMIZED=OFF zul√§ssig.  
  
> [!WARNING]  
>  Wenn eine Tabelle mit **DURABILITY = SCHEMA_ONLY** erstellt wird und **READ_COMMITTED_SNAPSHOT** anschlie√üend mithilfe von **ALTER DATABASE** ge√§ndert wird, gehen Daten in der Tabelle verloren.  
  
 BUCKET_COUNT  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)]. 
  
 Gibt die Anzahl der Buckets an, die im Hashindex erstellt werden sollen. Der maximale Wert f√ºr BUCKET_COUNT in Hashindizes betr√§gt 1.073.741.824. Weitere Informationen zu Indizes f√ºr speicheroptimierte Tabellen finden Sie unter [Indexes for Memory-Optimized Tables (Indizes f√ºr speicheroptimierte Tabellen)](../../relational-databases/in-memory-oltp/indexes-for-memory-optimized-tables.md).  
  
 Bucket_count ist ein erforderliches Argument.  
  
 INDEX  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)]. 
  
Spalten- und Tabellenindizes k√∂nnen als Teil der Anweisung CREATE TABLE angeben werden. Ausf√ºhrliche Informationen √ºber das Hinzuf√ºgen und Entfernen von Indizes von speicheroptimierten Tabellen finden Sie unter [√Ñndern von speicheroptimierten Tabellen](../../relational-databases/in-memory-oltp/altering-memory-optimized-tables.md)
  
 HASH  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL14](../../includes/sssql14-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)]. 
  
 Gibt an, dass ein HASH-Index erstellt wird.  
  
 Hashindizes werden nur f√ºr speicheroptimierte Tabellen unterst√ºtzt.  
  
## <a name="remarks"></a>Remarks  
 Informationen zur Anzahl zul√§ssiger Tabellen, Spalten, Einschr√§nkungen und Indizes finden Sie unter [Spezifikationen der maximalen Kapazit√§t f√ºr SQL Server](../../sql-server/maximum-capacity-specifications-for-sql-server.md).  
  
 Der Speicherplatz f√ºr Tabellen und Indizes wird i.¬†A. jeweils blockweise zugeordnet. Wenn die Option SET MIXED_PAGE_ALLOCATION von ALTER DATABASE beim Erstellen einer Tabelle oder eines Index auf TRUE festgelegt ist (bzw. ‚Äûalways‚Äú vor [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)]), werden so lange Seiten aus gemischten Bl√∂cken zugewiesen, bis ausreichend Seiten zum F√ºllen eines einheitlichen Blocks vorhanden sind. Wenn gen√ºgend Seiten f√ºr einen einheitlichen Block vorhanden sind, wird jedes Mal dann ein weiterer Block zugeordnet, wenn die bereits zugeordneten Bl√∂cke voll sind. F√ºhren Sie **sp_spaceused** aus, um einen Bericht dar√ºber zu erhalten, wie viel Speicherplatz f√ºr eine Tabelle zugeordnet ist und von dieser verwendet wird.  
  
 Das [!INCLUDE[ssDE](../../includes/ssde-md.md)] erzwingt keine Reihenfolge f√ºr die Angabe von DEFAULT, IDENTITY, ROWGUIDCOL oder Spalteneinschr√§nkungen in einer Spaltendefinition.  
  
 Beim Erstellen einer Tabelle wird die Option QUOTED IDENTIFIER immer mit der Einstellung ON in den Metadaten der Tabelle gespeichert, und zwar auch dann, wenn die Option beim Erstellen der Tabelle auf OFF festgelegt ist.  
  
## <a name="temporary-tables"></a>Tempor√§re Tabellen  
 Sie k√∂nnen sowohl lokale als auch globale tempor√§re Tabellen erstellen. Lokale tempor√§re Tabellen sind nur w√§hrend der aktuellen Sitzung sichtbar; globale tempor√§re Tabellen sind von allen Sitzungen aus sichtbar. Tempor√§re Tabellen k√∂nnen nicht partitioniert werden.  
  
 Stellen Sie lokalen tempor√§ren Tabellennamen ein einzelnes Nummernzeichen (#*table_name*) und globalen tempor√§ren Tabellennamen ein doppeltes Nummernzeichen voran (##*table_name*).  
  
 SQL-Anweisungen verweisen auf die tempor√§re Tabelle, indem sie den in der CREATE TABLE-Anweisung angegebenen Wert f√ºr *table_name* verwenden. Zum Beispiel:  
  
```  
CREATE TABLE #MyTempTable (cola INT PRIMARY KEY);  
  
INSERT INTO #MyTempTable VALUES (1);  
```  
  
 Wenn mehr als eine tempor√§re Tabelle innerhalb einer einzigen gespeicherten Prozedur oder innerhalb eines Batches erstellt wird, m√ºssen verschiedene Namen f√ºr die tempor√§ren Tabellen verwendet werden.  
  
 Wenn eine lokale tempor√§re Tabelle in einer gespeicherten Prozedur oder einer Anwendung erstellt wird, die von mehreren Benutzern gleichzeitig ausgef√ºhrt werden kann, muss es dem [!INCLUDE[ssDE](../../includes/ssde-md.md)] m√∂glich sein, die von den verschiedenen Benutzern erstellten Tabellen zu unterscheiden. Zu diesem Zweck f√ºgt das [!INCLUDE[ssDE](../../includes/ssde-md.md)] intern ein numerisches Suffix an alle Namen lokaler tempor√§rer Tabellen an. Der vollst√§ndige, in der Tabelle **sysobjects** von **tempdb** gespeicherte Name einer tempor√§ren Tabelle besteht aus dem in der CREATE TABLE-Anweisung angegebenen Tabellennamen und dem vom System generierten numerischen Suffix. Damit das Suffix angef√ºgt werden kann, darf *table_name* f√ºr eine lokale tempor√§re Tabelle nicht l√§nger als 116 Zeichen sein.  
  
 Tempor√§re Tabellen werden automatisch gel√∂scht, wenn sie nicht mehr g√ºltig sind, es sei denn, sie wurden bereits explizit mithilfe von DROP TABLE gel√∂scht:  
  
-   Eine lokale tempor√§re Tabelle, die in einer gespeicherten Prozedur erstellt wurde, wird bei Beendigung der gespeicherten Prozedur automatisch gel√∂scht. Auf die Tabelle kann durch geschachtelte gespeicherte Prozeduren verwiesen werden, die von der gespeicherten Prozedur ausgef√ºhrt werden, die die Tabelle erstellt hat. Auf die Tabelle kann nicht durch den Vorgang verwiesen werden, der die gespeicherte Prozedur, die die Tabelle erstellt hat, aufgerufen hat.  
  
-   Alle anderen lokalen tempor√§ren Tabellen werden am Ende der aktuellen Sitzung automatisch gel√∂scht.  
  
-   Eine globale tempor√§re Tabelle wird automatisch gel√∂scht, wenn die Sitzung, die die betreffende Tabelle erstellt hat, beendet wird und kein Task mehr auf die Tabelle verweist. Die Zuordnung zwischen einem Task und einer Tabelle wird nur f√ºr die Dauer einer einzelnen [!INCLUDE[tsql](../../includes/tsql-md.md)]-Anweisung aufrechterhalten. Das bedeutet, dass eine globale tempor√§re Tabelle bei Beendigung der letzten [!INCLUDE[tsql](../../includes/tsql-md.md)]-Anweisung gel√∂scht wird, die aktiv auf die Tabelle verwiesen hat, als die Sitzung, die die Tabelle erstellt hat, beendet wurde.  
  
 Eine lokale tempor√§re Tabelle, die in einer gespeicherten Prozedur oder einem Trigger erstellt wurde, kann den gleichen Namen wie eine tempor√§re Tabelle haben, die vor dem Aufruf der gespeicherten Prozedur oder des Triggers erstellt wurde. Wenn jedoch eine Abfrage auf eine tempor√§re Tabelle verweist und zu diesem Zeitpunkt zwei tempor√§re Tabellen mit demselben Namen vorhanden sind, ist nicht definiert, anhand welcher Tabelle die Abfrage aufgel√∂st werden soll. Eine geschachtelte gespeicherte Prozedur kann ebenfalls eine tempor√§re Tabelle mit demselben Namen wie eine tempor√§re Tabelle erstellen, die von der gespeicherten Prozedur erstellt wurde, die die geschachtelte gespeicherte Prozedur aufgerufen hat. Damit jedoch √Ñnderungsanweisungen anhand der Tabelle aufgel√∂st werden k√∂nnen, die in der geschachtelten Prozedur erstellt wurde, muss die Tabelle die gleiche Struktur mit den gleichen Spaltennamen wie die Tabelle aufweisen, die in der aufrufenden Prozedur erstellt wurde. Dies wird im folgenden Beispiel gezeigt.  
  
```  
CREATE PROCEDURE dbo.Test2  
AS  
n    CREATE TABLE #t(x INT PRIMARY KEY);  
    INSERT INTO #t VALUES (2);  
    SELECT Test2Col = x FROM #t;  
GO  
  
CREATE PROCEDURE dbo.Test1  
AS  
    CREATE TABLE #t(x INT PRIMARY KEY);  
    INSERT INTO #t VALUES (1);  
    SELECT Test1Col = x FROM #t;  
 EXEC Test2;  
GO  
  
CREATE TABLE #t(x INT PRIMARY KEY);  
INSERT INTO #t VALUES (99);  
GO  
  
EXEC Test1;  
GO  
```  
  
 [!INCLUDE[ssResult](../../includes/ssresult-md.md)]  
  
 ```
 (1 row(s) affected) 
 Test1Col 
 ----------- 
 1 

 (1 row(s) affected) 
 Test2Col 
 ----------- 
 2 
 ```
  
 Beim Erstellen lokaler oder globaler tempor√§rer Tabellen unterst√ºtzt die Syntax der CREATE TABLE-Anweisung Einschr√§nkungsdefinitionen mit Ausnahme von FOREIGN KEY-Einschr√§nkungen. Wenn eine FOREIGN KEY-Einschr√§nkung in einer tempor√§ren Tabelle angegeben wird, gibt die Anweisung ein Warnmeldung zur√ºck, die besagt, dass die Einschr√§nkung nicht ber√ºcksichtigt wurde. Die Tabelle wird dennoch, jedoch ohne die FOREIGN KEY-Einschr√§nkungen erstellt. In FOREIGN KEY-Einschr√§nkungen kann nicht auf tempor√§re Tabellen verwiesen werden.  
  
 Wenn eine tempor√§re Tabelle mit einer benannten Einschr√§nkung und innerhalb des Bereichs einer benutzerdefinierten Transaktion erstellt wird, kann jeweils nur ein Benutzer die Anweisung ausf√ºhren, mit der die tempor√§re Tabelle erstellt wird. Wenn zum Beispiel eine gespeicherte Prozedur eine tempor√§re Tabelle mit einer benannten Prim√§rschl√ºsseleinschr√§nkung erstellt, kann die gespeicherte Prozedur nicht von mehreren Benutzern gleichzeitig ausgef√ºhrt werden.  


## <a name="database-scoped-global-temporary-tables-azure-sql-database"></a>Datenbankweit g√ºltige globale tempor√§re Tabellen (Azure SQL-Datenbank)

Globale tempor√§re Tabellen f√ºr SQL Server (mit ‚Äû## table_name‚Äú initiiert) werden in ‚Äûtempdb‚Äú gespeichert und f√ºr alle Benutzersitzungen in der gesamten SQL Server-Instanz freigegeben. Informationen zu SQL-Tabellentypen finden Sie im obigen Abschnitt zum Erstellen von Tabellen.  

In Azure SQL-Datenbank werden globale tempor√§re Tabellen unterst√ºtzt, die in ‚Äûtempdb‚Äú gespeichert werden und auf Datenbankebene gelten.  Das hei√üt, dass globale tempor√§re Tabellen f√ºr alle Benutzersitzungen innerhalb derselben Azure SQL-Datenbank freigegeben werden. Benutzersitzungen von anderen Azure SQL-Datenbanken k√∂nnen nicht auf globale tempor√§re Tabellen zugreifen.

Globale tempor√§re Tabellen f√ºr Azure SQL-Datenbanken befolgen die gleiche Syntax und Semantik, die bei SQL Server f√ºr tempor√§re Tabellen verwendet werden.  Auf √§hnliche Weise gelten globale tempor√§re gespeicherte Prozeduren in Azure SQL-Datenbank auf Datenbankebene. Lokale tempor√§re Tabellen (mit ‚Äû# table_name‚Äú initiiert) werden auch f√ºr Azure SQL-Datenbank unterst√ºtzt und befolgen die gleiche Syntax und Semantik, die bei SQL Server verwendet werden.  Informationen dazu finden Sie im obigen Abschnitt [Tempor√§re Tabellen](#temporary-tables).  

> [!IMPORTANT]
> Dieses Feature ist nur f√ºr Azure SQL-Datenbank verf√ºgbar.
>

### <a name="troubleshooting-global-temporary-tables-for-azure-sql-db"></a>Problembehandlung bei globalen tempor√§ren Tabellen f√ºr Azure SQL-Datenbank 

Informationen zur Problembehandlung bei der Datenbank ‚Äûtempdb‚Äú finden Sie unter [Problembehandlung bei unzureichendem Speicherplatz in tempdb](https://technet.microsoft.com/library/ms176029%28v=sql.105%29.aspx?f=255&MSPPError=-2147217396). Sie m√ºssen ein Serveradministrator sein, um auf die dynamischen Verwaltungssichten f√ºr die Problembehandlung in Azure SQL-Datenbank zugreifen zu k√∂nnen.
  
### <a name="permissions"></a>Berechtigungen  

 Jeder Benutzer ist berechtigt, globale tempor√§re Objekte zu erstellen. Benutzer haben nur Zugriff auf ihre eigenen Objekte, es sei denn, ihnen wurden zus√§tzliche Berechtigungen zugewiesen. zugreifen.  
  
### <a name="examples"></a>Beispiele 

- Sitzung A erstellt die globale tempor√§re Tabelle ‚Äû##test‚Äú in der Datenbank ‚Äûtestdb1‚Äú in Azure SQL-Datenbank und f√ºgt eine Zeile hinzu.

```sql
CREATE TABLE ##test ( a int, b int);
INSERT INTO ##test values (1,1);

--Obtain object ID for temp table ##test 
SELECT OBJECT_ID('tempdb.dbo.##test') AS 'Object ID'; 

---Result
1253579504

---Obtain global temp table name for a given object ID 1253579504 in tempdb (2)
SELECT name FROM tempdb.sys.objects WHERE object_id = 1253579504

---Result
##test
```
- Sitzung B stellt eine Verbindung zu ‚Äûtestdb1‚Äú her und kann auf die von Sitzung A erstellte Tabelle ‚Äû##test‚Äú zugreifen.

```sql
SELECT * FROM ##test
---Results
1,1
```

- Sitzung C stellt eine Verbindung zu einer anderen Datenbank namens ‚Äûtestdb2‚Äú her und m√∂chte auf die Tabelle ‚Äû##test‚Äú in der Datenbank ‚Äûtestdb1‚Äú zugreifen. SELECT schl√§gt aufgrund des Datenbankbereichs f√ºr die globalen tempor√§ren Tabellen fehl. 

```sql
SELECT * FROM ##test
---Results
Msg 208, Level 16, State 0, Line 1
Invalid object name '##test'
```

- Adressieren des Systemobjekts in ‚Äûtempdb‚Äú in Azure SQL-Datenbank aus der aktuellen Benutzerdatenbank ‚Äûtestdb1‚Äú.

```sql
SELECT * FROM tempdb.sys.objects
SELECT * FROM tempdb.sys.columns
SELECT * FROM tempdb.sys.database_files
```



## <a name="partitioned-tables"></a>Partitionierte Tabellen  
 Bevor eine partitionierte Tabelle mithilfe von CREATE TABLE erstellt wird, m√ºssen Sie zuerst eine Partitionsfunktion erstellen, um anzugeben, wie die Tabelle partitioniert werden soll. Eine Partitionsfunktion wird mit [CREATE PARTITION FUNCTION](../../t-sql/statements/create-partition-function-transact-sql.md) erstellt. Dar√ºber hinaus m√ºssen Sie ein Partitionsschema erstellen, um die Dateigruppen anzugeben, die die von der Partitionsfunktion angegebenen Partitionen aufnehmen. Ein Partitionsschema wird mit [CREATE PARTITION SCHEME](../../t-sql/statements/create-partition-scheme-transact-sql.md) erstellt. Das Platzieren von PRIMARY KEY- oder UNIQUE-Einschr√§nkungen in verschiedenen Dateigruppen ist bei partitionierten Tabellen nicht m√∂glich. Weitere Informationen finden Sie unter [Partitioned Tables and Indexes](../../relational-databases/partitions/partitioned-tables-and-indexes.md).  
  
## <a name="primary-key-constraints"></a>PRIMARY KEY-Einschr√§nkungen  
  
-   Eine Tabelle kann nur eine PRIMARY KEY-Einschr√§nkung enthalten.  
  
-   Der durch eine PRIMARY KEY-Einschr√§nkung generierte Index kann nicht dazu f√ºhren, dass die Anzahl der Indizes der Tabelle 999 nicht gruppierte Indizes und 1 gruppierten Index √ºbersteigt.  
  
-   Wenn CLUSTERED oder NONCLUSTERED f√ºr eine PRIMARY KEY-Einschr√§nkung nicht angegeben ist, wird CLUSTERED verwendet, sofern keine gruppierten Indizes f√ºr UNIQUE-Einschr√§nkungen angegeben sind.  
  
-   Alle Spalten, f√ºr die eine PRIMARY KEY-Einschr√§nkung definiert wurde, m√ºssen als NOT NULL definiert sein. Falls weder NULL noch NOT NULL angegeben ist, wird f√ºr alle Spalten, auf die eine PRIMARY KEY-Einschr√§nkung angewendet wird, die NULL-Zul√§ssigkeit auf NOT NULL festgelegt.  
  
    > [!NOTE]  
    >  In speicheroptimierten Tabellen sind Schl√ºsselspalten mit NULL-Zul√§ssigkeit zul√§ssig.  
  
-   Wenn ein Prim√§rschl√ºssel f√ºr eine Spalte eines CLR-benutzerdefinierten Typs definiert wird, muss die Implementierung des Typs eine bin√§re Sortierreihenfolge unterst√ºtzen. Weitere Informationen finden Sie unter [Benutzerdefinierte CLR-Typen](../../relational-databases/clr-integration-database-objects-user-defined-types/clr-user-defined-types.md).  
  
## <a name="unique-constraints"></a>UNIQUE-Einschr√§nkungen  
  
-   Wenn CLUSTERED oder NONCLUSTERED f√ºr eine UNIQUE-Einschr√§nkung nicht angegeben ist, wird standardm√§√üig NONCLUSTERED verwendet.  
  
-   Jede UNIQUE-Einschr√§nkung erzeugt einen Index. Die Anzahl der UNIQUE-Einschr√§nkungen kann nicht dazu f√ºhren, dass die Anzahl der Indizes der Tabelle 999 nicht gruppierte Indizes und 1 gruppierten Index √ºbersteigt.  
  
-   Wenn eine UNIQUE-Einschr√§nkung f√ºr eine Spalte eines CLR-benutzerdefinierten Typs definiert wird, muss die Implementierung des Typs eine bin√§re oder operatorbasierte Sortierreihenfolge unterst√ºtzen. Weitere Informationen finden Sie unter [Benutzerdefinierte CLR-Typen](../../relational-databases/clr-integration-database-objects-user-defined-types/clr-user-defined-types.md).  
  
## <a name="foreign-key-constraints"></a>Fremdschl√ºsseleinschr√§nkungen  
  
-   Wenn ein anderer Wert als NULL in die Spalte einer FOREIGN KEY-Einschr√§nkung eingegeben wird, muss der Wert in der Spalte vorhanden sein, auf die verwiesen wird; andernfalls wird eine Fremdschl√ºsselverletzungs-Fehlermeldung zur√ºckgegeben.  
  
-   FOREIGN KEY-Einschr√§nkungen werden auf die vorangegangene Spalte angewendet, es sei denn, es werden Quellspalten angegeben.  
  
-   FOREIGN KEY-Einschr√§nkungen k√∂nnen nur auf Tabellen verweisen, die sich innerhalb derselben Datenbank auf demselben Server befinden. Datenbank√ºbergreifende referenzielle Integrit√§t muss durch Trigger implementiert werden. Weitere Informationen finden Sie unter [CREATE TRIGGER &#40;Transact-SQL&#41;](../../t-sql/statements/create-trigger-transact-sql.md).  
  
-   FOREIGN KEY-Einschr√§nkungen k√∂nnen auf eine andere Spalte in derselben Tabelle verweisen. Ein solcher Verweis wird als Eigenverweis bezeichnet.  
  
-   Die REFERENCES-Klausel einer FOREIGN KEY-Einschr√§nkung auf Spaltenebene kann nur eine Verweisspalte auflisten. Diese Spalte muss denselben Datentyp aufweisen wie die Spalte, f√ºr die die Einschr√§nkung definiert wurde.  
  
-   Die REFERENCES-Klausel einer FOREIGN KEY-Einschr√§nkung auf Tabellenebene muss ebenso viele Verweisspalten haben, wie sich Spalten in der Einschr√§nkungsspaltenliste befinden. Der Datentyp jeder Verweisspalte muss ebenfalls mit dem der entsprechenden Spalte in der Spaltenliste √ºbereinstimmen.  
  
-   CASCADE, SET NULL oder SET DEFAULT k√∂nnen nicht angegeben werden, wenn eine Spalte vom Typ **timestamp** Teil des Fremdschl√ºssels oder des Schl√ºssels ist, auf den verwiesen wird.  
  
-   CASCADE, SET NULL, SET DEFAULT und NO ACTION k√∂nnen f√ºr Tabellen kombiniert werden, die referenzielle Beziehungen untereinander aufweisen. Wenn das [!INCLUDE[ssDE](../../includes/ssde-md.md)] die Einstellung NO ACTION feststellt, wird die Verarbeitung beendet und ein Rollback f√ºr verbundene CASCADE-, SET NULL- und SET DEFAULT-Aktionen ausgef√ºhrt. Wenn eine DELETE-Anweisung eine Kombination aus CASCADE-, SET NULL-, SET DEFAULT- und NO ACTION-Aktionen bewirkt, werden alle CASCADE-, SET NULL- und SET DEFAULT-Aktionen angewendet, bevor das [!INCLUDE[ssDE](../../includes/ssde-md.md)] nach der m√∂glichen Angabe von NO ACTION sucht.  
  
-   Das [!INCLUDE[ssDE](../../includes/ssde-md.md)] verf√ºgt √ºber keine vordefinierte Grenze hinsichtlich der Anzahl von FOREIGN KEY-Einschr√§nkungen, die eine Tabelle, die auf andere Tabellen verweist, enthalten kann, oder hinsichtlich der Anzahl von FOREIGN KEY-Einschr√§nkungen im Besitz anderer Tabellen, die auf eine bestimmte Tabelle verweisen.  
  
     Nichtsdestotrotz ist die tats√§chliche Anzahl von FOREIGN KEY-Einschr√§nkungen , die verwendet werden k√∂nnen, durch die Hardwarekonfiguration und den Entwurf der Datenbank und der Anwendung begrenzt. Als Empfehlung gilt, dass eine Tabelle maximal 253 FOREIGN KEY-Einschr√§nkungen enthalten sollte und dass maximal 253 FOREIGN KEY-Einschr√§nkungen auf eine Tabelle verweisen sollten. Die in Ihrem Fall tats√§chlich g√ºltige Grenze kann je nach Anwendung und Hardware dar√ºber oder darunter liegen. Beim Entwerfen von Datenbank und Anwendungen sollten Sie die Kosten f√ºr das Erzwingen von FOREIGN KEY-Einschr√§nkungen ber√ºcksichtigen.  
  
-   FOREIGN KEY-Einschr√§nkungen werden nicht auf tempor√§re Tabellen angewendet.  
  
-   FOREIGN KEY-Einschr√§nkungen k√∂nnen nur auf Spalten in PRIMARY KEY- oder UNIQUE-Einschr√§nkungen in der Tabelle, auf die verwiesen wird, oder auf eine UNIQUE INDEX-Einschr√§nkung f√ºr die Tabelle, auf die verwiesen wird, verweisen.  
  
-   Wenn ein Fremdschl√ºssel f√ºr eine Spalte eines CLR-benutzerdefinierten Typs definiert wird, muss die Implementierung des Typs eine bin√§re Sortierreihenfolge unterst√ºtzen. Weitere Informationen finden Sie unter [Benutzerdefinierte CLR-Typen](../../relational-databases/clr-integration-database-objects-user-defined-types/clr-user-defined-types.md).  
  
-   F√ºr Spalten, die an einer Fremdschl√ºsselbeziehung beteiligt sind, muss die gleiche L√§nge und Skala definiert sein.  
  
## <a name="default-definitions"></a>DEFAULT-Definitionen  
  
-   Eine Spalte kann nur eine DEFAULT-Definition haben.  
  
-   Eine DEFAULT-Definition kann konstante Werte, Funktionen, standardm√§√üige NILADIC-SQL-Funktionen oder NULL enthalten. Die folgende Tabelle zeigt die Funktionen ohne Argumente und die Werte, die sie w√§hrend einer INSERT-Anweisung f√ºr den Standardwert zur√ºckgeben.  
  
    |SQL-92-Funktion ohne Argumente|Zur√ºckgegebener Wert|  
    |------------------------------|--------------------|  
    |CURRENT_TIMESTAMP|Aktuelles Datum und aktuelle Uhrzeit.|  
    |CURRENT_USER|Name des Benutzers, der einen Einf√ºgevorgang ausf√ºhrt.|  
    |SESSION_USER|Name des Benutzers, der einen Einf√ºgevorgang ausf√ºhrt.|  
    |SYSTEM_USER|Name des Benutzers, der einen Einf√ºgevorgang ausf√ºhrt.|  
    |Benutzer|Name des Benutzers, der einen Einf√ºgevorgang ausf√ºhrt.|  
  
-   *constant_expression* in einer DEFAULT-Definition kann nicht auf eine andere Spalte in der Tabelle oder auf andere Tabellen, Sichten oder gespeicherte Prozeduren verwiesen werden.  
  
-   DEFAULT-Definitionen k√∂nnen nicht f√ºr Spalten mit einem **timestamp**-Datentyp oder f√ºr Spalten mit IDENTITY-Eigenschaft erstellt werden.  
  
-   DEFAULT-Definitionen k√∂nnen nicht f√ºr Spalten mit Aliasdatentypen erstellt werden, wenn der Aliasdatentyp an ein Standardobjekt gebunden ist.  
  
## <a name="check-constraints"></a>CHECK-Einschr√§nkungen  
  
-   Eine Spalte kann beliebig viele CHECK-Einschr√§nkungen haben, und die Bedingung kann mehrere logische Ausdr√ºcke enthalten, die mit AND und OR verkn√ºpft sind. Mehrere CHECK-Einschr√§nkungen f√ºr eine Spalte werden in der Reihenfolge √ºberpr√ºft, in der sie erstellt wurden.  
  
-   Die Suchbedingung muss einen booleschen Ausdruck ergeben und darf nicht auf eine andere Tabelle verweisen.  
  
-   Eine CHECK-Einschr√§nkung auf Spaltenebene kann nur auf die von der Einschr√§nkung betroffene Spalte verweisen, und eine CHECK-Einschr√§nkung auf Tabellenebene kann nur auf Spalten derselben Tabelle verweisen.  
  
     CHECK-Einschr√§nkungen und Regeln dienen beide zur √úberpr√ºfung der Daten w√§hrend INSERT- und UPDATE-Anweisungen.  
  
-   Sobald eine Regel und mindestens eine CHECK-Einschr√§nkung f√ºr eine oder mehrere Spalten vorhanden sind, werden alle Einschr√§nkungen ausgewertet.  
  
-   CHECK-Einschr√§nkungen k√∂nnen nicht f√ºr Spalten vom Typ **text**, **ntext** oder **image** definiert werden.  
  
## <a name="additional-constraint-information"></a>Weitere Informationen zu Einschr√§nkungen  
  
-   Ein f√ºr eine Einschr√§nkung erstellter Index kann nicht mit der DROP INDEX-Anweisung gel√∂scht werden. Die Einschr√§nkung muss mithilfe von ALTER TABLE gel√∂scht werden. Ein Index, der f√ºr eine Einschr√§nkung erstellt wurde und von ihr verwendet wird, kann mithilfe von ALTER INDEX...REBUILD neu erstellt werden. Weitere Informationen finden Sie unter [Neuorganisieren und Neuerstellen von Indizes](../../relational-databases/indexes/reorganize-and-rebuild-indexes.md).  
  
-   Einschr√§nkungsnamen m√ºssen den Regeln f√ºr [Bezeichner](../../relational-databases/databases/database-identifiers.md) entsprechen, wobei der Name nicht mit einem Nummernzeichen (#) beginnen darf. Wenn *constraint_name* nicht angegeben ist, vergibt das System einen Namen f√ºr die Einschr√§nkung. Der Einschr√§nkungsname wird in jeder Fehlermeldung √ºber Einschr√§nkungsverletzungen angezeigt.  
  
-   Wenn eine Einschr√§nkung in einer INSERT-, UPDATE- oder DELETE-Anweisung verletzt wird, wird die Anweisung beendet. Wenn SET XACT_ABORT jedoch auf OFF festgelegt ist, wird die Verarbeitung der Transaktion ‚Äì falls die Anweisung Teil einer expliziten Transaktion ist ‚Äì fortgesetzt. Wenn SET XACT_ABORT auf ON festgelegt ist, wird f√ºr die ganze Transaktion ein Rollback ausgef√ºhrt. Sie k√∂nnen auch die ROLLBACK TRANSACTION-Anweisung mit der Transaktionsdefinition verwenden, indem Sie die @@ERROR-Systemfunktion pr√ºfen.  
  
-   Wenn ALLOW_ROW_LOCKS auf ON und ALLOW_PAGE_LOCK auf ON festgelegt ist, sind Sperren auf Zeilen-, Seiten- und Tabellenebene beim Zugriff auf den Index zul√§ssig. Das [!INCLUDE[ssDE](../../includes/ssde-md.md)] w√§hlt die geeignete Sperre aus und kann die Sperre von einer Zeilen- oder Seitensperre auf eine Tabellensperre ausweiten. Wenn ALLOW_ROW_LOCKS auf OFF und ALLOW_PAGE_LOCK auf OFF festgelegt sind, sind beim Zugriff auf den Index nur Sperren auf Tabellenebene zul√§ssig.  
  
-   Wenn eine Tabelle FOREIGN KEY- oder CHECK-Einschr√§nkungen und Trigger hat, werden die Einschr√§nkungsbedingungen ausgewertet, bevor der Trigger ausgef√ºhrt wird.  
  
 Verwenden Sie **sp_help** oder **sp_helpconstraint**, um einen Bericht √ºber eine Tabelle und deren Spalten zu erhalten. Zum Umbenennen einer Tabelle verwenden Sie **sp_rename**. Verwenden Sie f√ºr einen Bericht zu den Sichten und gespeicherten Prozeduren, die von einer Tabelle abh√§ngen, [sys.dm_sql_referenced_entities](../../relational-databases/system-dynamic-management-views/sys-dm-sql-referenced-entities-transact-sql.md) und [sys.dm_sql_referencing_entities](../../relational-databases/system-dynamic-management-views/sys-dm-sql-referencing-entities-transact-sql.md).  
  
## <a name="nullability-rules-within-a-table-definition"></a>NULL-Zul√§ssigkeitsregeln in einer Tabellendefinition  
 Die NULL-Zul√§ssigkeit einer Spalte bestimmt, ob diese Spalte NULL als Datenwert enthalten kann. NULL ist nicht Null oder leer. NULL bedeutet, dass kein Eintrag vorgenommen oder explizit NULL angegeben wurde, und impliziert √ºblicherweise, dass der Wert entweder unbekannt oder nicht anwendbar ist.  
  
 Wenn Sie CREATE TABLE- oder ALTER TABLE verwenden, um eine Tabelle zu erstellen bzw. zu √§ndern, wird die NULL-Zul√§ssigkeit des in einer Spaltendefinition verwendeten Datentyps durch Datenbank- und Sitzungseinstellungen beeinflusst und m√∂glicherweise √ºberschrieben. Es empfiehlt sich, bei nicht berechneten Spalten stets explizit NULL oder NOT NULL f√ºr die Spalte anzugeben oder, im Falle eines benutzerdefinierten Datentyps, zuzulassen, dass die Spalte die standardm√§√üige NULL-Zul√§ssigkeit des Datentyps verwendet. Spalten mit geringer Dichte m√ºssen immer NULL zulassen.  
  
 Wenn die NULL-Zul√§ssigkeit der Spalte nicht explizit angegeben ist, wird sie gem√§√ü den in der folgenden Tabelle aufgef√ºhrten Regeln hergeleitet.  
  
|Spaltendatentyp|Regel|  
|----------------------|----------|  
|Aliasdatentyp|Das [!INCLUDE[ssDE](../../includes/ssde-md.md)] verwendet die NULL-Zul√§ssigkeit, die beim Erstellen des Datentyps angegeben wurde. Verwenden Sie **sp_help** zum Bestimmen der standardm√§√üigen NULL-Zul√§ssigkeit des Datentyps.|  
|CLR-benutzerdefinierter Typ|Die NULL-Zul√§ssigkeit wird gem√§√ü der Spaltendefinition bestimmt.|  
|Vom System bereitgestellter Datentyp|Wenn es f√ºr den vom System bereitgestellten Datentyp nur eine Option gibt, hat diese Vorrang. F√ºr **timestamp**-Datentypen muss NOT NULL angegeben werden. Wenn Sitzungseinstellungen mithilfe von SET auf ON festgelegt werden, gilt Folgendes:<br />Wenn **ANSI_NULL_DFLT_ON** auf ON festgelegt ist, wird NULL zugewiesen.  <br />Wenn **ANSI_NULL_DFLT_OFF** auf ON festgelegt ist, wird NOT NULL zugewiesen.<br /><br /> Wenn Datenbankeinstellungen mithilfe von ALTER DATABASE konfiguriert werden, gilt Folgendes:<br />Wenn **ANSI_NULL_DEFAULT_ON** auf ON festgelegt ist, wird NULL zugewiesen.  <br />Wenn **ANSI_NULL_DEFAULT_OFF** auf ON festgelegt ist, wird NOT NULL zugewiesen.<br /><br /> Zum Anzeigen der Datenbankeinstellungen f√ºr ANSI_NULL_DEFAULT verwenden Sie die Katalogsicht **sys.databases**.|  
  
 Wenn keine der ANSI_NULL_DFLT-Optionen f√ºr die Sitzung festgelegt wurde und f√ºr die Datenbank die Standardeinstellung gilt (ANSI_NULL_DEFAULT ist auf OFF festgelegt), wird der Standardwert NOT NULL zugewiesen.  
  
 Wenn es sich bei der Spalte um eine berechnete Spalte handelt, wird die NULL-Zul√§ssigkeit stets automatisch durch das [!INCLUDE[ssDE](../../includes/ssde-md.md)] bestimmt. Zum Bestimmen der NULL-Zul√§ssigkeit dieser Art von Spalte verwenden Sie die Funktion COLUMNPROPERTY mit der Eigenschaft **AllowsNull**.  
  
> [!NOTE]  
>  F√ºr den SQL¬†Server-ODBC-Treiber und den Microsoft OLE DB Provider f√ºr SQL Server ist ANSI_NULL_DFLT_ON standardm√§√üig auf ON festgelegt. ODBC- und OLE¬†DB-Benutzer k√∂nnen dies in ODBC-Datenquellen oder mit von der Anwendung festgelegten Verbindungsattributen oder -eigenschaften konfigurieren.  
  
## <a name="data-compression"></a>Datenkomprimierung  
 F√ºr Systemtabellen ist die Komprimierung nicht verf√ºgbar. Bei Erstellung einer Tabelle wird die Datenkomprimierung auf NONE festgelegt, falls nicht anders angegeben. Wenn Sie eine Partitionsliste bzw. eine Partition au√üerhalb des zul√§ssigen Bereichs angeben, wird ein Fehler generiert. Weitere Informationen zur Datenkomprimierung finden Sie unter [Datenkomprimierung](../../relational-databases/data-compression/data-compression.md).  
  
 Mit der gespeicherten Prozedur [sp_estimate_data_compression_savings](../../relational-databases/system-stored-procedures/sp-estimate-data-compression-savings-transact-sql.md) k√∂nnen Sie einsch√§tzen, wie sich eine √Ñnderung des Komprimierungsstatus auf eine Tabelle, einen Index oder eine Partition auswirkt.  
  
## <a name="permissions"></a>Berechtigungen  
 Es sind die CREATE TABLE-Berechtigung in der Datenbank und die ALTER-Berechtigung f√ºr das Schema erforderlich, in der die Tabelle erstellt wird.  
  
 Wenn in der CREATE TABLE-Anweisung eine Spalte als Spalte eines CLR-benutzerdefinierten Typs definiert wird, ist entweder der Besitz des Typs oder die REFERENCES-Berechtigung f√ºr den Typ erforderlich.  
  
 Wenn einer Spalte in der CREATE TABLE-Anweisung eine XML-Schemaauflistung zugeordnet ist, ist entweder der Besitz der XML-Schemaauflistung oder die REFERENCES-Berechtigung f√ºr die Auflistung erforderlich.  
  
 Jeder Benutzer ist berechtigt, tempor√§re Tabellen in tempdb zu erstellen.  
  
## <a name="examples"></a>Beispiele  
  
### <a name="a-create-a-primary-key-constraint-on-a-column"></a>A. Erstellen einer PRIMARY KEY-Einschr√§nkung f√ºr eine Spalte  
 Im folgenden Beispiel ist die Spaltendefinition f√ºr eine PRIMARY KEY-Einschr√§nkung dargestellt, die √ºber einen gruppierten Index f√ºr die `EmployeeID`-Spalte der `Employee`-Tabelle verf√ºgt. Da kein Einschr√§nkungsname angegeben ist, wird der Einschr√§nkungsname vom System angegeben.  
  
```  
CREATE TABLE dbo.Employee (EmployeeID int  
PRIMARY KEY CLUSTERED);  
```  
  
### <a name="b-using-foreign-key-constraints"></a>B. Verwenden von FOREIGN KEY-Einschr√§nkungen  
 Eine FOREIGN KEY-Einschr√§nkung wird zum Verweisen auf eine andere Tabelle verwendet. Fremdschl√ºssel k√∂nnen einspaltige oder mehrspaltige Schl√ºssel sein. Dieses Beispiel zeigt eine einspaltige FOREIGN KEY-Einschr√§nkung f√ºr die `SalesOrderHeader`-Tabelle, die auf die `SalesPerson`-Tabelle verweist. F√ºr eine einspaltige FOREIGN KEY-Einschr√§nkung wird nur die REFERENCES-Klausel ben√∂tigt.  
  
```  
SalesPersonID int NULL  
REFERENCES SalesPerson(SalesPersonID)  
```  
  
 Sie k√∂nnen auch explizit die FOREIGN KEY-Klausel verwenden und das Spaltenattribut nochmals nennen. Beachten Sie, dass der Spaltenname in den beiden Tabellen nicht identisch sein muss.  
  
```  
FOREIGN KEY (SalesPersonID) REFERENCES SalesPerson(SalesPersonID)  
```  
  
 Einschr√§nkungen f√ºr mehrspaltige Schl√ºssel werden als Tabelleneinschr√§nkungen erstellt. Die `SpecialOfferProduct`-Tabelle in der [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)]-Datenbank enth√§lt einen mehrspaltigen Prim√§rschl√ºssel. Das folgende Beispiel zeigt, wie von einer anderen Tabelle aus auf diesen Schl√ºssel verwiesen wird; die Angabe eines expliziten Einschr√§nkungsnamens ist optional.  
  
```  
CONSTRAINT FK_SpecialOfferProduct_SalesOrderDetail FOREIGN KEY  
 (ProductID, SpecialOfferID)  
REFERENCES SpecialOfferProduct (ProductID, SpecialOfferID)  
```  
  
### <a name="c-using-unique-constraints"></a>C. Verwenden von UNIQUE-Einschr√§nkungen  
 UNIQUE-Einschr√§nkungen werden verwendet, um Eindeutigkeit f√ºr Nicht-Prim√§rschl√ºsselspalten zu erzwingen. Im folgenden Beispiel wird eine Einschr√§nkung erzwungen, durch die festgelegt wird, dass die `Name`-Spalte der `Product`-Tabelle eindeutig sein muss.  
  
```  
Name nvarchar(100) NOT NULL  
UNIQUE NONCLUSTERED  
```  
  
### <a name="d-using-default-definitions"></a>D. Verwenden von DEFAULT-Definitionen  
 Standardwerte stellen jeweils einen Wert bereit (in INSERT- und UPDATE-Anweisungen), wenn kein Wert angegeben ist. Die [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)]-Datenbank k√∂nnte beispielsweise eine Nachschlagetabelle enthalten, in der die verschiedenen T√§tigkeiten aufgelistet sind, die Mitarbeiter in dem Unternehmen aus√ºben k√∂nnen. In einer Spalte, in der jede T√§tigkeit beschrieben wird, k√∂nnte ein Zeichenfolgen-Standardwert eine Beschreibung bereitstellen, falls keine explizite Angabe einer Beschreibung erfolgt.  
  
```  
DEFAULT 'New Position - title not formalized yet'  
```  
  
 Neben Konstanten k√∂nnen DEFAULT-Definitionen auch Funktionen enthalten. Verwenden Sie das folgende Beispiel, um das aktuelle Datum f√ºr einen Eintrag zu erhalten.  
  
```  
DEFAULT (getdate())  
```  
  
 Eine Funktion ohne Argumente kann ebenfalls zur Verbesserung der Datenintegrit√§t beitragen. Verwenden Sie die Funktion ohne Argumente f√ºr USER, um den Benutzer nachzuverfolgen, der eine Zeile einf√ºgt. Schlie√üen Sie die Funktionen ohne Argumente nicht in Klammern ein.  
  
```  
DEFAULT USER  
```  
  
### <a name="e-using-check-constraints"></a>E. Verwenden von CHECK-Einschr√§nkungen  
 Im folgenden Beispiel wird eine Einschr√§nkung gezeigt, die f√ºr Werte gilt, die in die `CreditRating`-Spalte der `Vendor`-Tabelle eingegeben werden. Die Einschr√§nkung ist nicht benannt.  
  
```  
CHECK (CreditRating >= 1 and CreditRating <= 5)  
```  
  
 Dieses Beispiel zeigt eine benannte Einschr√§nkung mit Mustereinschr√§nkung f√ºr die Zeichendaten, die in eine Spalte einer Tabelle eingegeben werden.  
  
```  
CONSTRAINT CK_emp_id CHECK (emp_id LIKE   
'[A-Z][A-Z][A-Z][1-9][0-9][0-9][0-9][0-9][FM]'   
OR emp_id LIKE '[A-Z]-[A-Z][1-9][0-9][0-9][0-9][0-9][FM]')  
```  
  
 Dieses Beispiel gibt an, dass die Werte in einer speziellen Liste enthalten sein m√ºssen oder einem bestimmten Muster entsprechen m√ºssen.  
  
```  
CHECK (emp_id IN ('1389', '0736', '0877', '1622', '1756')  
OR emp_id LIKE '99[0-9][0-9]')  
```  
  
### <a name="f-showing-the-complete-table-definition"></a>F. Anzeigen der vollst√§ndigen Tabellendefinition  
 Im folgenden Beispiel werden die vollst√§ndigen Tabellendefinitionen mit allen Einschr√§nkungsdefinitionen f√ºr die in der [!INCLUDE[ssSampleDBobject](../../includes/sssampledbobject-md.md)]-Datenbank erstellte `PurchaseOrderDetail`-Tabelle angezeigt. Beachten Sie, dass zum Ausf√ºhren des Beispiels das Tabellenschema nach `dbo` ge√§ndert wird.  
  
```  
CREATE TABLE dbo.PurchaseOrderDetail  
(  
    PurchaseOrderID int NOT NULL  
        REFERENCES Purchasing.PurchaseOrderHeader(PurchaseOrderID),  
    LineNumber smallint NOT NULL,  
    ProductID int NULL   
        REFERENCES Production.Product(ProductID),  
    UnitPrice money NULL,  
    OrderQty smallint NULL,  
    ReceivedQty float NULL,  
    RejectedQty float NULL,  
    DueDate datetime NULL,  
    rowguid uniqueidentifier ROWGUIDCOL  NOT NULL  
        CONSTRAINT DF_PurchaseOrderDetail_rowguid DEFAULT (newid()),  
    ModifiedDate datetime NOT NULL   
        CONSTRAINT DF_PurchaseOrderDetail_ModifiedDate DEFAULT (getdate()),  
    LineTotal  AS ((UnitPrice*OrderQty)),  
    StockedQty  AS ((ReceivedQty-RejectedQty)),  
    CONSTRAINT PK_PurchaseOrderDetail_PurchaseOrderID_LineNumber  
               PRIMARY KEY CLUSTERED (PurchaseOrderID, LineNumber)  
               WITH (IGNORE_DUP_KEY = OFF)  
)   
ON PRIMARY;  
```  
  
### <a name="g-creating-a-table-with-an-xml-column-typed-to-an-xml-schema-collection"></a>G. Erstellen einer Tabelle mit einer XML-Spalte, die mit einer XML-Schemaauflistung typisiert wird  
 Im folgenden Beispiel wird eine Tabelle mit einer `xml`-Spalte erstellt, die mit der XML-Schemaauflistung `HRResumeSchemaCollection` typisiert wird. Das Schl√ºsselwort `DOCUMENT` gibt an, dass jede Instanz des Datentyps `xml` in *column_name* nur ein allgemeines Element enthalten kann.  
  
```  
CREATE TABLE HumanResources.EmployeeResumes   
   (LName nvarchar(25), FName nvarchar(25),   
    Resume xml( DOCUMENT HumanResources.HRResumeSchemaCollection) );  
```  
  
### <a name="h-creating-a-partitioned-table"></a>H. Erstellen einer partitionierten Tabelle  
 Im folgenden Beispiel wird eine Partitionsfunktion zum Partitionieren einer Tabelle oder eines Indexes in vier Partitionen erstellt. Anschlie√üend wird im Beispiel ein Partitionsschema erstellt, das die Dateigruppen angibt, die jede der vier Partitionen aufnehmen sollen. Schlie√ülich wird eine Tabelle erstellt, die das Partitionsschema verwendet. In diesem Beispiel wird davon ausgegangen, dass die Dateigruppen bereits in der Datenbank vorhanden sind.  
  
```  
CREATE PARTITION FUNCTION myRangePF1 (int)  
    AS RANGE LEFT FOR VALUES (1, 100, 1000) ;  
GO  
  
CREATE PARTITION SCHEME myRangePS1  
    AS PARTITION myRangePF1  
    TO (test1fg, test2fg, test3fg, test4fg) ;  
GO  
  
CREATE TABLE PartitionTable (col1 int, col2 char(10))  
    ON myRangePS1 (col1) ;  
GO  
```  
  
 Basierend auf den Werten der `col1`-Spalte von `PartitionTable` werden die Partitionen folgenderma√üen zugewiesen.  
  
|Dateigruppe|test1fg|test2fg|test3fg|test4fg|  
|---------------|-------------|-------------|-------------|-------------|  
|**Partition**|1|2|3|4|  
|**Werte**|col1 \<= 1|col1 > 1 AND col1 \<= 100|col1 > 100 AND col1 \<= 1,000|col1 > 1000|  
  
### <a name="i-using-the-uniqueidentifier-data-type-in-a-column"></a>I. Verwenden des uniqueidentifier-Datentyps in einer Spalte  
 Im folgenden Beispiel wird eine Tabelle mit einer `uniqueidentifier`-Spalte erstellt. In dem Beispiel wird eine PRIMARY KEY-Einschr√§nkung verwendet, um zu verhindern, dass Benutzer doppelte Werte in die Tabelle einf√ºgen. Mithilfe der `NEWSEQUENTIALID()`-Funktion in der `DEFAULT`-Einschr√§nkung werden Werte f√ºr neue Zeilen bereitgestellt. Die ROWGUIDCOL-Eigenschaft wird auf die `uniqueidentifier`-Spalte angewendet, sodass mit dem $ROWGUID-Schl√ºsselwort auf sie verwiesen werden kann.  
  
```  
CREATE TABLE dbo.Globally_Unique_Data  
    (guid uniqueidentifier   
        CONSTRAINT Guid_Default DEFAULT   
        NEWSEQUENTIALID() ROWGUIDCOL,  
    Employee_Name varchar(60)  
    CONSTRAINT Guid_PK PRIMARY KEY (guid) );  
```  
  
### <a name="j-using-an-expression-for-a-computed-column"></a>J. Verwenden eines Ausdrucks f√ºr eine berechnete Spalte  
 Im folgenden Beispiel wird die Verwendung eines Ausdrucks (`(low + high)/2`) zum Berechnen der berechneten Spalte `myavg` verwendet.  
  
```  
CREATE TABLE dbo.mytable   
    ( low int, high int, myavg AS (low + high)/2 ) ;  
```  
  
### <a name="k-creating-a-computed-column-based-on-a-user-defined-type-column"></a>K. Erstellen einer berechneten Spalte basierend auf einer Spalte eines benutzerdefinierten Typs  
 Im folgenden Beispiel wird eine Tabelle mit einer Spalte erstellt, die als Spalte des benutzerdefinierten Typs `utf8string` definiert ist. Hierbei wird vorausgesetzt, dass die Assembly des Typs und der Typ selbst bereits in der aktuellen Datenbank erstellt wurden. Eine zweite Spalte wird basierend auf `utf8string` definiert. Hierbei wird die `ToString()`-Methode von **type(class)**`utf8string` verwendet, um einen Wert f√ºr die Spalte zu berechnen.  
  
```  
CREATE TABLE UDTypeTable   
    ( u utf8string, ustr AS u.ToString() PERSISTED ) ;  
```  
  
### <a name="l-using-the-username-function-for-a-computed-column"></a>L. Verwenden der USER_NAME-Funktion f√ºr eine berechnete Spalte  
 Im folgenden Beispiel wird die `USER_NAME()`-Funktion in der `myuser_name`-Spalte verwendet.  
  
```  
CREATE TABLE dbo.mylogintable  
    ( date_in datetime, user_id int, myuser_name AS USER_NAME() ) ;  
```  
  
### <a name="m-creating-a-table-that-has-a-filestream-column"></a>M. Erstellen einer Tabelle mit einer FILESTREAM-Spalte  
 Im folgenden Beispiel wird eine Tabelle mit der `FILESTREAM`-Spalte `Photo` erstellt. Eine Tabelle mit einer oder mehreren `FILESTREAM`-Spalten muss eine `ROWGUIDCOL`-Spalte enthalten.  
  
```  
CREATE TABLE dbo.EmployeePhoto  
    (  
    EmployeeId int NOT NULL PRIMARY KEY,  
    ,Photo varbinary(max) FILESTREAM NULL  
    ,MyRowGuidColumn uniqueidentifier NOT NULL ROWGUIDCOL  
        UNIQUE DEFAULT NEWID()  
    );  
```  
  
### <a name="n-creating-a-table-that-uses-row-compression"></a>N. Erstellen einer Tabelle, in der Zeilenkomprimierung verwendet wird  
 Im folgenden Beispiel wird eine Tabelle erstellt, in der Zeilenkomprimierung verwendet wird.  
  
```  
CREATE TABLE dbo.T1   
(c1 int, c2 nvarchar(200) )  
WITH (DATA_COMPRESSION = ROW);  
```  
  
 Weitere Beispiele f√ºr die Datenkomprimierung finden Sie unter [Datenkomprimierung](../../relational-databases/data-compression/data-compression.md).  
  
### <a name="o-creating-a-table-that-has-sparse-columns-and-a-column-set"></a>O. Erstellen einer Tabelle mit Sparsespalten und einem Spaltensatz  
 Anhand der folgenden Beispiele wird gezeigt, wie Sie eine Tabelle mit einer Sparsespalte und eine Tabelle mit zwei Sparsespalten und einem Spaltensatz erstellen. In den Beispielen wird die grundlegende Syntax verwendet. Komplexere Beispiele finden Sie unter [Verwenden von Spalten mit geringer Dichte](../../relational-databases/tables/use-sparse-columns.md) und [Verwenden von Spaltens√§tzen](../../relational-databases/tables/use-column-sets.md).  
  
 In diesem Beispiel wird eine Tabelle erstellt, die eine Sparsespalte enth√§lt.  
  
```  
CREATE TABLE dbo.T1  
    (c1 int PRIMARY KEY,  
    c2 varchar(50) SPARSE NULL ) ;  
```  
  
 In diesem Beispiel wird eine Tabelle erstellt, die zwei Sparsespalten und einen Spaltensatz mit dem Namen `CSet` enth√§lt.  
  
```  
CREATE TABLE T1  
    (c1 int PRIMARY KEY,  
    c2 varchar(50) SPARSE NULL,  
    c3 int SPARSE NULL,  
    CSet XML COLUMN_SET FOR ALL_SPARSE_COLUMNS ) ;  
```  
  
### <a name="p-creating-a-system-versioned-disk-based-temporal-table"></a>P. Erstellen einer datentr√§gerbasierten temporalen Tabelle mit Systemversionsverwaltung  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 In den folgenden Beispielen wird gezeigt, wie Sie temporale Tabellen erstellen, die mit einer neuen Verlaufstabelle verbunden sind, und wie Sie temporale Tabellen erstellen, die mit einer vorhandenen Verlaufstabelle verbunden sind. Beachten Sie, dass der Prim√§rschl√ºssel der temporalen Tabelle definiert sein muss, damit die Versionsverwaltung durch das System f√ºr die Tabelle aktiviert werden kann. Beispiele f√ºr das Hinzuf√ºgen und Entfernen der Versionsverwaltung durch das System bei einer vorhandenen Tabelle finden Sie unter [Beispiele f√ºr die Versionsverwaltung durch das System](../../t-sql/statements/alter-table-transact-sql.md#Example_Top). Anwendungsf√§lle finden Sie unter [Temporale Tabellen](../../relational-databases/tables/temporal-tables.md).  
  
 In diesem Beispiel wird eine neue temporale Tabelle mit einer neuen Verlaufstabelle verbunden.  
  
```  
CREATE TABLE Department   
(  
    DepartmentNumber char(10) NOT NULL PRIMARY KEY CLUSTERED,   
    DepartmentName varchar(50) NOT NULL,   
    ManagerID int  NULL,   
    ParentDepartmentNumber char(10) NULL,   
    SysStartTime datetime2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL,   
    SysEndTime datetime2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL,     
    PERIOD FOR SYSTEM_TIME (SysStartTime,SysEndTime)     
)  
WITH (SYSTEM_VERSIONING = ON);  
```  
  
 In diesem Beispiel wird eine neue temporale Tabelle mit einer vorhandenen Verlaufstabelle verbunden.  
  
```  
  
--Existing table   
CREATE TABLE Department_History   
(  
    DepartmentNumber char(10) NOT NULL,   
    DepartmentName varchar(50) NOT NULL,   
    ManagerID int  NULL,   
    ParentDepartmentNumber char(10) NULL,   
    SysStartTime datetime2 NOT NULL,   
    SysEndTime datetime2 NOT NULL   
);  
--Temporal table  
CREATE TABLE Department   
(  
    DepartmentNumber char(10) NOT NULL PRIMARY KEY CLUSTERED,   
    DepartmentName varchar(50) NOT NULL,   
    ManagerID INT  NULL,   
    ParentDepartmentNumber char(10) NULL,   
    SysStartTime datetime2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL,   
    SysEndTime datetime2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL,     
    PERIOD FOR SYSTEM_TIME (SysStartTime,SysEndTime)    
)  
WITH   
    (SYSTEM_VERSIONING = ON   
        (HISTORY_TABLE = dbo.Department_History, DATA_CONSISTENCY_CHECK = ON )  
    );  
```  
  
### <a name="q-creating-a-system-versioned-memory-optimized-temporal-table"></a>Q. Erstellen einer speicheroptimierten temporalen Tabelle mit Systemversionsverwaltung  
   
  
**Gilt f√ºr**: [!INCLUDE[ssSQL15](../../includes/sssql15-md.md)] bis [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] und [!INCLUDE[ssSDSfull](../../includes/sssdsfull-md.md)].
  
 Im folgenden Beispiel wird gezeigt, wie eine speicheroptimierte temporale Tabelle mit Versionsverwaltung durch das System erstellt wird, die mit einer neuen datentr√§gerbasierten Verlaufstabelle verbunden ist.  
  
 In diesem Beispiel wird eine neue temporale Tabelle mit einer neuen Verlaufstabelle verbunden.  
  
```  
CREATE SCHEMA History  
GO  
CREATE TABLE dbo.Department   
(  
    DepartmentNumber char(10) NOT NULL PRIMARY KEY NONCLUSTERED,   
    DepartmentName varchar(50) NOT NULL,   
    ManagerID int  NULL,   
    ParentDepartmentNumber char(10) NULL,   
    SysStartTime datetime2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL,   
    SysEndTime datetime2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL,     
    PERIOD FOR SYSTEM_TIME (SysStartTime,SysEndTime)     
)  
WITH   
    (  
        MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA,  
            SYSTEM_VERSIONING = ON ( HISTORY_TABLE = History.DepartmentHistory )   
    );  
```  
  
 In diesem Beispiel wird eine neue temporale Tabelle mit einer vorhandenen Verlaufstabelle verbunden.  
  
```  
  
--Existing table   
CREATE TABLE Department_History   
(  
    DepartmentNumber char(10) NOT NULL,   
    DepartmentName varchar(50) NOT NULL,   
    ManagerID int  NULL,   
    ParentDepartmentNumber char(10) NULL,   
    SysStartTime datetime2 NOT NULL,   
    SysEndTime datetime2 NOT NULL   
);  
--Temporal table  
CREATE TABLE Department   
(  
    DepartmentNumber char(10) NOT NULL PRIMARY KEY CLUSTERED,   
    DepartmentName varchar(50) NOT NULL,   
    ManagerID INT  NULL,   
    ParentDepartmentNumber char(10) NULL,   
    SysStartTime datetime2 GENERATED ALWAYS AS ROW START HIDDEN NOT NULL,   
    SysEndTime datetime2 GENERATED ALWAYS AS ROW END HIDDEN NOT NULL,     
    PERIOD FOR SYSTEM_TIME (SysStartTime,SysEndTime)    
)  
WITH   
    (SYSTEM_VERSIONING = ON   
        (HISTORY_TABLE = dbo.Department_History, DATA_CONSISTENCY_CHECK = ON )  
    );  
```  
  
### <a name="r-creating-a-table-with-encrypted-columns"></a>R. Erstellen einer Tabelle mit verschl√ºsselten Spalten  
 Im folgenden Beispiel wird eine Tabelle mit zwei verschl√ºsselten Spalten erstellt. Weitere Informationen finden Sie unter [Always Encrypted &#40;Datenbankmodul&#41;](../../relational-databases/security/encryption/always-encrypted-database-engine.md).  
  
```  
CREATE TABLE Customers (  
    CustName nvarchar(60)   
        ENCRYPTED WITH   
            (  
             COLUMN_ENCRYPTION_KEY = MyCEK,  
             ENCRYPTION_TYPE = RANDOMIZED,  
             ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256'  
            ),   
    SSN varchar(11) COLLATE  Latin1_General_BIN2  
        ENCRYPTED WITH   
            (  
             COLUMN_ENCRYPTION_KEY = MyCEK,  
             ENCRYPTION_TYPE = DETERMINISTIC ,  
             ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256'  
            ),   
    Age int NULL  
);  
```

### <a name="s-create-an-inline-filtered-index"></a>S. Erstellen eines inlinegefilterten Index 
Erstellt eine Tabelle mit einem inlinegefilterten Index.
  
  ```
  CREATE TABLE t1 
 (
      c1 int,
      index IX1  (c1) WHERE c1 > 0   
 )
GO
 ```
 
  
## <a name="see-also"></a>Weitere Informationen finden Sie unter  
 [ALTER TABLE &#40;Transact-SQL&#41;](../../t-sql/statements/alter-table-transact-sql.md)   
 [COLUMNPROPERTY (Transact-SQL)](../../t-sql/functions/columnproperty-transact-sql.md)   
 [CREATE INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/create-index-transact-sql.md)   
 [CREATE VIEW &#40;Transact-SQL&#41;](../../t-sql/statements/create-view-transact-sql.md)   
 [Datentypen &#40;Transact-SQL&#41;](../../t-sql/data-types/data-types-transact-sql.md)   
 [DROP INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/drop-index-transact-sql.md)   
 [sys.dm_sql_referenced_entities &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-sql-referenced-entities-transact-sql.md)   
 [sys.dm_sql_referencing_entities &#40;Transact-SQL&#41;](../../relational-databases/system-dynamic-management-views/sys-dm-sql-referencing-entities-transact-sql.md)   
 [DROP TABLE &#40;Transact-SQL&#41;](../../t-sql/statements/drop-table-transact-sql.md)   
 [CREATE PARTITION FUNCTION &#40;Transact-SQL&#41;](../../t-sql/statements/create-partition-function-transact-sql.md)   
 [CREATE PARTITION SCHEME &#40;Transact-SQL&#41;](../../t-sql/statements/create-partition-scheme-transact-sql.md)   
 [CREATE TYPE &#40;Transact-SQL&#41;](../../t-sql/statements/create-type-transact-sql.md)   
 [EVENTDATA &#40;Transact-SQL&#41;](../../t-sql/functions/eventdata-transact-sql.md)   
 [sp_help &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-help-transact-sql.md)   
 [sp_helpconstraint &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-helpconstraint-transact-sql.md)   
 [sp_rename &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-rename-transact-sql.md)   
 [sp_spaceused &#40;Transact-SQL&#41;](../../relational-databases/system-stored-procedures/sp-spaceused-transact-sql.md)  
  
  


